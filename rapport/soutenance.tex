\documentclass{beamer}

\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{nameref}
\usepackage[symbol]{footmisc}
\usepackage{minitoc}
\usepackage{color}
\usepackage{amsmath}
\usepackage[francais]{babel}
\usepackage{natbib}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage[footheight=1em]{beamerthemeboxes}
\usepackage{array}
\setcounter{tocdepth}{3}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\renewcommand{\contentsname}{Table des matières}

\input{macros/macros}
\input{macros/macros-ph}
\input{macros/tikzstyles2.tex}

\setbeamertemplate{footline}{
\leavevmode
\hbox{\hspace*{-0.06cm}
\begin{beamercolorbox}[wd=.2\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}
	\usebeamerfont{author in head/foot}\insertshortauthor  %~~(\insertshortinstitute)
\end{beamercolorbox}
\begin{beamercolorbox}[wd=.6\paperwidth,ht=2.25ex,dp=1ex,center]{section in head/foot}
	\usebeamerfont{section in head/foot}\insertshorttitle
\end{beamercolorbox}
\begin{beamercolorbox}[wd=.2\paperwidth,ht=2.25ex,dp=1ex,right]{section in head/foot}
	\usebeamerfont{section in head/foot}\hspace*{2em}
	\insertframenumber{} / \inserttotalframenumber\hspace*{2ex}
\end{beamercolorbox}}
\vskip0pt
}



\title{Analyse de la dynamique des modèles biologiques par programmation logique}
\author{Léo-Paul Delsaux}
\institute{Stage effectué au laboratoire CRIStAL de Villeneuve-d'Ascq}
\date{29 août 2022}

% ceci est un commentaire
% pour compiler : tapez pdflatex ex-presentation
% regardez ensuite le fichier ex-presentation.pdf

\begin{document}

\maketitle

\begin{frame}{Introduction}
	Mots-clés :
	\begin{itemize}
		\item Bio-informatique
		\item Answer Set Programming (ASP)
		\item Réseau d'automates asynchrone (AAN)
		\item \'Etat local/global, transition locale/globale, chemin, cycle, automate produit, attracteur
	\end{itemize}
\end{frame}

\begin{frame}{Hitori}
	\begin{figure}[!h]
		\includegraphics[width=6cm]{hitori.png}
		\caption{Grille de Hitori (\href{https://fr.wikipedia.org/wiki/Hitori}{https://fr.wikipedia.org/wiki/Hitori})}
		\label{label-figure1}
	\end{figure}
\end{frame}

\begin{frame}{Hitori - Instance}
	\pause
	c(1,1,2). c(2,1,2). c(3,1,1). c(4,1,5). c(5,1,3).\\
	c(1,2,2). c(2,2,3). c(3,2,1). c(4,2,4). c(5,2,5).\\
	c(1,3,1). c(2,3,1). c(3,3,1). c(4,3,3). c(5,3,5).\\
	c(1,4,1). c(2,4,3). c(3,4,5). c(4,4,4). c(5,4,2).\\
	c(1,5,5). c(2,5,4). c(3,5,3). c(4,5,2). c(5,5,1).\\
\end{frame}

\begin{frame}{Hitori - Règles}
	\textcolor{blue}{
	\pause
	taille(5).\\
	\pause
	\textcolor{white}{cheatcode}\\
	\textcolor{red}{\emph{Faits utiles}}\\
	colonne(1..S) :- taille(S).\\
	ligne(1..S) :- taille(S).\\
	\pause
	\textcolor{white}{cheatcode}\\
	\textcolor{red}{\emph{Déclaration des colorations}}\\
	couleur(blanc). couleur(jaune).\\
	\pause
	\textcolor{white}{cheatcode}\\
	\textcolor{red}{\emph{Génération des différents ensembles solutions}}\\
	1 \{ sol(L, C, V) : couleur(V) \} 1 :- colonne(C), ligne(L).}\\
\end{frame}

\begin{frame}{Hitori - Règles (suite)}
	\pause
	\textcolor{red}{\emph{Il ne peut pas y avoir deux cases jaunes juxtaposées}}\\
	\textcolor{blue}{:- sol(L, C, jaune), sol(L+1, C, jaune).\\
	\pause
	:- sol(L, C, jaune), sol(L-1, C, jaune).\\
	:- sol(L, C, jaune), sol(L, C+1, jaune).\\
	:- sol(L, C, jaune), sol(L, C-1, jaune).\\
	\pause
	\textcolor{white}{cheatcode}\\
	\textcolor{red}{\emph{Les cases blanches sur une même ligne/colonne ont toutes une valeur différente}}\\
	:- sol(L, C, blanc), sol(L, C2, blanc), C != C2, c(L, C, V), c(L, C2, V).\\
	\pause
	:- sol(L, C, blanc), sol(L2, C, blanc), L != L2, c(L, C, V), c(L2, C, V).}\\
\end{frame}

\begin{frame}{Hitori - Règles (suite)}
	\pause
	\textcolor{red}{\emph{L'ensemble des cases blanches est connexe (par déplacement haut/bas/gauche/droite)}}\\
	\textcolor{blue}{chemin((L, C),(L+1, C)) :- sol(L, C, blanc), sol(L+1, C, blanc).\\
	\pause
	chemin((L, C),(L-1, C)) :- sol(L, C, blanc), sol(L-1, C, blanc).\\
	chemin((L, C),(L, C+1)) :- sol(L, C, blanc), sol(L, C+1, blanc).\\
	chemin((L, C),(L, C-1)) :- sol(L, C, blanc), sol(L, C-1, blanc).\\
	\pause
	chemin((L1, C1), (L2, C2)) :- chemin((L1, C1), (X, Y)), chemin((X, Y), (L2, C2)).\\
	\pause
	:- sol(L, C, blanc), sol(L2, C2, blanc), not chemin((L, C), (L2, C2)).}\\
\end{frame}

\begin{frame}{Hitori résolu}
	\begin{figure}[!h]
		\includegraphics[width=6cm]{Hitori_2.png}
		\caption{Grille de Hitori résolu (\href{https://fr.wikipedia.org/wiki/Hitori}{https://fr.wikipedia.org/wiki/Hitori})}
		\label{label-figure2}
	\end{figure}
\end{frame}

\begin{frame}{Sokoban}
	\begin{figure}[!h]
		\includegraphics[width=6cm]{Diagram1.eps}
		\caption{Grille de Sokoban. P symbolise le joueur, les ronds rouges sont les cases d'arrivée, et les carrés rouges représentent les caisses.}
		\label{label-figure3}
	\end{figure}
\end{frame}

\begin{frame}{Sokoban - Stratégies de calcul}
	\pause
	Naïf : on considère un coup en tant que déplacement possible du personnage
	\begin{figure}[!h]
		\pause
		\includegraphics[width=3.25cm]{Coup1_strat1.eps}
		\includegraphics[width=3.25cm]{Coup2_strat1.eps}
		\includegraphics[width=3.25cm]{Coup3_strat1.eps}
	\end{figure}
\end{frame}

\begin{frame}{Sokoban - Stratégies de calcul}
	\pause
	Plus rapide : on ne considère que les coups de déplacement de caisse. On considère alors l'ensemble connexe des cases atteignables depuis celles du personnage
	\begin{figure}[!h]
		\pause
		\includegraphics[width=3.25cm]{Coup1_strat2.eps}
		\includegraphics[width=3.25cm]{Coup2_strat2.eps}
		\includegraphics[width=3.25cm]{Coup3_strat2.eps}
	\end{figure}
\end{frame}

\begin{frame}{AAN - Schéma}
	\begin{figure}[!h]
		\pause
		\centering  
		\begin{tikzpicture}[apdotsimple/.style={apdot}]
		  \TSort{(0,2)}{a}{3}{r}
		  \TSort{(2.5,0)}{b}{2}{r}
		  \TSort{(5,2)}{c}{3}{r}

		  \path[local transitions]
		    (a_0) edge node[auto] {$b_0$} (a_1)
		    (a_1) edge node[auto] {$b_0$} (a_2)
		    (a_2) edge node[auto] {$b_1$} (a_1)
		    (a_1) edge node[auto] {$b_1$} (a_0)

		    (b_0) edge node[auto] {$c_0$} (b_1)
		    (b_1) edge node[auto] {$a_2$} (b_0)

		    (c_0) edge node[auto] {$b_1$} (c_1)
		    (c_1) edge node[auto] {$b_0$} (c_0)
		    (c_1) edge node[auto] {$a_1$} (c_2)
		    ;
		  \path[local transitions, bend left = 105]
		      (a_0) edge node[auto] {$b_1, c_1$} (a_1)
		    ;
		  \path[local transitions, bend left = 90]
		      (c_0) edge node[auto] {$a_2$} (c_2)
		    ;
		  \path[local transitions, bend left = 90]
		      (c_2) edge node[auto] {$b_1$} (c_0)
		    ;

		  \TState{a_0, b_1, c_1}
		\end{tikzpicture}
		
		\caption{Schéma qui fera office d'exemple de référence}
		\label{label-figure4}
	\end{figure}
\end{frame}

\begin{frame}{AAN - Formalismes}
	Un réseau d'automates asynchrone est un triplet $(\Sigma,S,T)$, avec :
	\begin{itemize}
		\pause
		\item $\Sigma=\left\{a,b,...\right\}$ est un ensemble fini d'automates non vides.\\
		\pause
		\textcolor{green}{$\Sigma =\left\{a,b,c\right\}$}\\
		\textcolor{white}{cheatcode}\\
		\pause
		\item Si $C_a$ est le nombre d'états d'un automate $a$, alors $S_a=\left\{a_0,a_1,...,a_{C_a-1}\right\}$ est l'ensemble des \textbf{états locaux} de $a$. $S=\displaystyle{\prod_{a\in\Sigma}}S_a$ est 
		l'ensemble fini des \textbf{états globaux}, et $LS=\displaystyle{\bigcup_{a\in\Sigma}}S_a$ représente l'ensemble de tous les états locaux.\\
		\pause
		\textcolor{green}{$S_a=\left\{a_0,a_1,a_2\right\}$, $S_b=\left\{b_0,b_1\right\}$ et $S_c=\left\{c_0,c_1,c_2\right\}$}\\
		\textcolor{white}{cheatcode}\\
	\end{itemize}
\end{frame}

\begin{frame}{AAN - Formalismes}
	\begin{itemize}
		\pause
		\item Pour chaque $a\in\Sigma$, $T_a\subseteq\left\{a_i\xrightarrow{l}a_j\in S_a\times\mathbb{P}(LS/S_a)\times S_a|a_i\neq a_j\right\}$ est l'ensemble des \textbf{transitions locales} d'un automate $a$. 
		$T=\displaystyle{\bigcup_{a\in\Sigma}}T_a$ est l'ensemble des transitions locales du modèle.
		\pause
		\textcolor{green}{$T_a = \left\{a_0\xrightarrow{b_0}a_1,a_0\xrightarrow{b_1,c_1}a_1,a_1\xrightarrow{b_1}a_0,a_1\xrightarrow{b_0}a_2,a_2\xrightarrow{b_1}a_1\right\}$\\
				  $T_b=\left\{b_0\xrightarrow{c_0}b_1,b_1\xrightarrow{a_2}b_0\right\}$\\
				  $T_c=\left\{c_0\xrightarrow{b_1}c_1,c_0\xrightarrow{a_2}c_2,c_1\xrightarrow{b_0}c_0,c_1\xrightarrow{a_1}c_2,c_2\xrightarrow{b_1}c_0\right\}$}\\
	\end{itemize}
\end{frame}

\begin{frame}{AAN - Traduction de l'exemple en ASP}
	En ASP, on définit l'exemple de référence en deux temps.\\
	\begin{itemize}
		\pause
		\item On déclare les niveaux : \\
			\textcolor{blue}{
			automaton\_level("a", 0..2).\\
			automaton\_level("b", 0..1).\\
			automaton\_level("c", 0..2).\\
			}
		\pause
		\item Et les transitions à l'aide de labels : \\
			\textcolor{blue}{
			condition(t1, "a", 0). target(t1, "a", 1). condition(t1, "b", 0).\\
			condition(t2, "a", 1). target(t2, "a", 2). condition(t2, "b", 0).}\\
			\verb![...]!(11 lignes supplémentaires)\\
			\textcolor{blue}{condition(t12, "a", 0). target(t12, "a", 1). condition(t12, "b", 1). condition(t12, "c", 1).\\
			}
	\end{itemize}
\end{frame}

\begin{frame}{Sémantiques}
	\pause
	On s'intéressera à 3 sémantiques : 
	\begin{figure}[!h]
		\pause
		\includegraphics[width=10cm]{Screenshot.png}
		\caption{Schéma repris du pdf Folschette\_Bioss18.pdf de Maxime Folschette}
	\end{figure}
\end{frame}

\begin{frame}{Attracteurs}
	\pause
	Un \textbf{domaine de piège} est un ensemble d'états globaux duquel toutes les transitions globales pour la sémantique choisie mènent à un élément de ce domaine.\\
	\begin{figure}[!h]
		\pause
		\includegraphics[width=7cm]{presonal_example_synch.eps}
		\caption{Sous-graphe du graphe produit de l'exemple de référence avec la sémantique synchrone. 3 des 6 domaines de piège y sont encadrés.}
	\end{figure}
\end{frame}

\begin{frame}{Attracteurs (suite)}
	\pause
	Un \textbf{attracteur} est un domaine de piège minimal en terme d'inclusion ensembliste.\\
	\begin{figure}[!h]
		\pause
		\includegraphics[width=7cm]{presonal_example_synch2.eps}
		\caption{Sous-graphe du graphe produit de l'exemple de référence avec la sémantique synchrone. Le seul attracteur y est encadré.}
	\end{figure}
	\pause
	\textcolor{white}{cheatcode}\\
	\textbf{Lemme :} Les attracteurs d'un AAN sont exactement les domaines de piège cycliques.
\end{frame}

\begin{frame}{Problématique}
	Pour la version synchrone, le code préexistant ne fonctionnait que partiellement : seuls les attracteurs simples (dont les états globaux ont exactement une transition sortante) étaient trouvés.\\
	\begin{figure}[!h]
		\pause
		\begin{tikzpicture}[apdotsimple/.style={apdot}]

			\TSort{(0,2)}{a}{3}{r}
			\TSort{(3,2)}{b}{3}{r}

			\path[local transitions]
			(a_0) edge node[auto] {$b_0$} (a_1)
			(a_1) edge node[auto] {$b_1$} (a_2)
			(a_2) edge node[auto] {$b_1$} (a_1)
			
			(b_0) edge node[auto] {$a_0$} (b_1)
			(b_1) edge node[auto] {$a_1$} (b_2)
			(b_2) edge node[auto] {$a_1$} (b_1)
			;
			
			\path[local transitions, bend left = 90]
			(a_0) edge node[auto] {$b_0$} (a_2)
			;
			
			\path[local transitions, bend left = 90]
			(a_2) edge node[auto] {$b_2$} (a_0)
			;
			
			\path[local transitions, bend left = 90]
			(b_0) edge node[auto] {$a_0$} (b_2)
			;
			
			\path[local transitions, bend left = 90]
			(b_2) edge node[auto] {$a_2$} (b_0)
			;
		\end{tikzpicture}
		\caption{Exemple d'AAN sur lequel le code pré-existant ne trouvait pas l'attracteur}
	\end{figure}
\end{frame}

\begin{frame}{Problématique}
	\begin{figure}[h!]
		\label{label-figure3}
		\includegraphics[width=5cm]{Diagram2.eps}
		\caption{Graphe produit de l'AAN précédent pour la sémantique synchrone}
	\end{figure}
\end{frame}

\begin{frame}{Pistes étudiées}
	\pause
	Solutions étudiées : 
	\begin{itemize}
		\pause
		\item correction de la troisième contrainte en Python
		\pause
		\item utilisation des états globaux en ASP
	\end{itemize}
\end{frame}

\begin{frame}{Correction de la troisième contrainte en Python}
	\pause
	Une fois que l'on a généré tous les chemins possibles dans un AAN à l'aide d'agrégats, il nous faut filtrer les ensembles-solutions qui nous intéressent. On doit alors respecter 3 contraintes : \\
	\begin{itemize}
		\pause
		\item avoir un cycle
		\pause
		\item tout les états globaux du chemin visités après l'étape de fin du visite du cycle doivent être des éléments de ce dernier
		\pause
		\item toutes les transitions globales jouables depuis chacun des éléments du cycle doivent arriver dans un autre élément de ce cycle ( = domaine piège)\\
	\end{itemize}
\end{frame}

\begin{frame}{Correction de la troisième contrainte en Python - Résultats}
	\begin{figure}[!h]
		\begin{tabular}{l|c<{\onslide<2->}c<{\onslide<3->}c<{\onslide<4->}c<{\onslide<5->}c<{\onslide<6->}c<{\onslide<7->}c<{\onslide}c}
			n & exam. & lamb. & trp. & fis. & mamm. & tcr. & t-helper \\ \hline
			$|\Sigma|$ & 4 & 4 & 4 & 9 & 10 & 40 & 101\\ \hline
			2     & 2 & 2 & 0 & 1 & 0 & 0 & 8878+\\
			5     & 2 & 2 & 1 & 1 & 0 & 0 & 5477+\\
			10    & 2 & 2 & 1 & 1 & 1 & 1 & 4072+\\
			15    & 2 & 2 & 1 & 1 & 1 & 1 & 2850+
		\end{tabular}
		\caption{Nombre d'attracteurs trouvés pour la sémantique synchrone (version avec python)}
		\label{label-figure5}
	\end{figure}
	
	\begin{figure}[!h]
		\begin{tabular}{l|c<{\onslide<2->}c<{\onslide<3->}c<{\onslide<4->}c<{\onslide<5->}c<{\onslide<6->}c<{\onslide<7->}c<{\onslide}c}
			n & exam. & lamb. & trp. & fis. & mamm. & tcr. & t-helper \\ \hline
			2     & .051 & .053 & .044 & .047 & .047 & .049 & T.O\\
			5     & .052 & .060 & .039 & .057 & .043 & .079 & T.O\\
			10    & .054 & .076 & .050 & .084 & .082 & .201 & T.O\\
			15    & .093 & .096 & .051 & .108 & .123 & .362 & T.O
		\end{tabular}
		\caption{Temps (en s) de résolution pour la sémantique synchrone (version avec python) - timeout(T.O) = 100s}
		\label{label-figure6}
	\end{figure}
\end{frame}

\begin{frame}{Utilisation des états globaux en ASP}
	\pause
	Une autre manière de gérer la troisième contrainte consiste à créer des prédicats pour les états globaux, et de mémoriser dans la sémantique quels sont les coups jouables depuis un état global, et non une étape temporelle 	
	donnée.\\
	
\end{frame}

\begin{frame}{Seconde solution : travail sur les états globaux - Résultats}
	\begin{figure}[!h]
		\begin{tabular}{l|c<{\onslide<2->}c<{\onslide<3->}c<{\onslide<4->}c<{\onslide<5->}c<{\onslide<6->}c<{\onslide<7->}c<{\onslide}c}
			n & exam. & lamb. & trp. & fis. & mamm. & tcr. & t-helper \\ \hline
			$|\Sigma|$ & 4 & 4 & 4 & 9 & 10 & 40 & 101\\ \hline
			2     & 2 & 2 & 0 &  &  &  & \\
			5     & 2 & 2 & 0 &  &  &  & \\
			10    & 2 &  & 0 &  &  &  & \\
			15    & 2 &  & 1 &  &  &  & 
		\end{tabular}
		\caption{Nombre d'attracteurs trouvés pour la sémantique synchrone (version avec états globaux)}
		\label{label-figure7}
	\end{figure}
	
	\begin{figure}[!h]
		\begin{tabular}{l|c<{\onslide<2->}c<{\onslide<3->}c<{\onslide<4->}c<{\onslide<5->}c<{\onslide<6->}c<{\onslide<7->}c<{\onslide}c}
			n & exam. & lamb. & trp. & fis. & mamm. & tcr. & t-helper \\ \hline
			2     & 3.724 & 43.623 & 4.155 & T.O & T.O & T.O & T.O\\
			5     & 6.457 & 71.786 & 6.288 & T.O & T.O & T.O & T.O\\
			10    & 11.349 & T.O & 11.561 & T.O & T.O & T.O & T.O\\
			15    & 18.767 & T.O & 19.636 & T.O & T.O & T.O & T.O
		\end{tabular}
		\caption{Temps (en s) de résolution pour la sémantique synchrone (version avec états globaux) - timeout(T.O) = 100s}
		\label{label-figure8}
	\end{figure}
\end{frame}

\begin{frame}{Conclusions (et pistes)}
	\begin{itemize}
		\pause
		\item 2 versions fonctionnelles :
		\begin{itemize}
			\item une efficace avec du filtrage sous Python
			\item l'autre moins efficace avec utilisation d'états globaux (avec quelques fonctions de calcul en Python)
		\end{itemize}
		\pause
		\item Pistes : la seconde version pourrait être améliorée avec de l'incrémental ; considérer des classes d'équivalence des attracteurs, et manipuler des sortes de "bassins d'attraction"
	\end{itemize}
\end{frame}

\begin{frame}{Remerciements}
	Merci à :
	\begin{itemize}
		\item l'ENS de Lyon qui m'a proposé ce stage
		\item Maxime Folschette pour son encadrement
		\item les personnes au sein de l'équipe BioComputing
		\item mes quelques collègues stagiaires de bureau
		\item les auditeurs présents dans cette salle pour leur écoute
	\end{itemize}
\end{frame}

\end{document}



