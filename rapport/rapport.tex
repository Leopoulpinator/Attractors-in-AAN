\documentclass[10pt,a4paper]{article}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage[a4paper,hmargin=21mm,vmargin=25mm]{geometry}
\usepackage{nameref}
\usepackage[symbol]{footmisc}
\usepackage{minitoc}
\usepackage{color}
\usepackage{amsmath}
\usepackage[francais]{babel}
\usepackage{natbib}
\usepackage{amssymb}
\setcounter{tocdepth}{3}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\renewcommand{\contentsname}{Table des matières}

\bibliographystyle{plainnat}

\input{macros/macros}
\input{macros/macros-ph}
\input{macros/tikzstyles2.tex}

\begin{document}

\begin{titlepage}
    \begin{center}
        \textsc{\Large Rapport de stage de L3}\\

    \vspace{2.5cm}

        \HRule\\
        {\huge\scshape Analyse de la dynamique des modèles biologiques par programmation logique\par}
        \HRule\\

    \vspace{3cm}

        \large
        Léo-Paul \textsc{Delsaux}\footnote[2]{ENS de Lyon}\\

    \vspace{1cm}

        \large
        \emph{Encadrant du stage} \\
        Maxime \textsc{Folschette}\footnote[3]{Équipe BioComputing - Univ. Lille, CNRS, Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France}\\

   \vspace{1cm}
   
      \large
      \emph{Laboratoire d'accueil}\\
      CRIStAL\\

    \vfill

        {\large Juin-Août 2022}
    \end{center}
\end{titlepage}

\addtocontents{toc}{\protect\hypertarget{toc}{}}

\fancypagestyle{plain}{%
\fancyhf{}
\cfoot{\hyperlink{toc}{\thepage}}%
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}}
\pagestyle{plain}%

\newpage
\tableofcontents

\newpage
\section{Introduction}

\subsection{Contexte}
La biologie s'intéresse à l'étude des systèmes vivants ou composants le vivant (gènes, cellules, écosystèmes...). La bioinformatique est l'utilisation de méthodes informatiques pour aider la biologie. Un des domaines de la 
bioinformatique s'apelle la \emph{biologie des systèmes} et consiste à proposer des modèles et des méthodes informatiques et mathématiques pour représenter et étudier de tels systèmes.\\ \\
L'étude de la dynamique des systèmes biologiques lève plusieurs problèmes tels que l'identification d'attracteurs, les bifurcations ou encore la connexité entre deux états globaux. Dans ce rapport je vais discuter de la recherche 
d'attracteurs dans des réseaux d'automates asynchrones : il s'agit d'un ensemble d'états duquel on ne peut pas s'échapper et minimal au sens de l'inclusion.\\ \\
Ce rapport fait écho au chapitre de \cite{chapitre}. Mon stage a démarré par la lecture complète de ce chapitre, nécessaire pour traiter le sujet.
Je vais donc commencer mon rapport en introduisant les notions majeures de ce chapitre.

\subsection{Plan}
Answer Set Programming (= ASP) est un langage de programmation logique particulièrement efficace pour résoudre des problèmes combinatoires. Mon stage s'est concentré sur l'étude d'ASP afin de chercher les attracteurs parmi le 
graphe des états globaux de notre réseau. J'ai également utilisé un peu de scripting Python, utile pour filtrer les ensembles solutions. J'explique brièvement le fonctionnement d'ASP dans la section \hyperref[asp]{Answer Set 
Programming}.\\ \\
Des études biologiques permettent de déterminer comment certains gènes interagissent entre eux, ce qui peut être représenté mathématiquement sous la forme d'un graphe. De plus, ces interactions peuvent être vues comme des 
transitions entre les sommets de notre graphe, ce qui se rapproche alors plus d'un automate. La représentation du modèle étudié lors de ce stage est expliqué dans la section \hyperref[fad]{Formalismes d'automates et leur 
dynamique}.\\ \\
Le travail pré-existant sur la recherche des attracteurs dans un réseau d'automates asynchrone ne fonctionnait pas sur toutes les sémantiques. Ma contribution personnelle a été de créer deux versions à partir de ce travail : 
une qui se charge de résoudre le problème pour la sémantique synchrone uniquement, et une autre  universelle pour les sémantiques. Je présente ces deux versions dans la section \hyperref[ccp]{Cœur de la contribution 
personnelle}.\\ \\
Ce qui sera étudié dans ce rapport ne le sera que partiellement : on n'entrera pas en détail dans le code présenté, mais on se penchera simplement sur les grandes lignes et sur les points techniques qu'il arbore.

\section{Answer Set Programming}
\label{asp}
L'Answer Set Programming (ASP) est un langage de programmation logique comparable à Prolog [\cite{Baral03}]. Ces dernières décennies, ASP s'est trouvé être puissant pour traiter des modèles biologiques, permettant de parcourir 
un grand nombre de configurations rapidement. ASP peut énumérer facilement les ensembles solutions à un problème qu'on lui encode : c'est un langage très efficace pour la combinatoire. Je vais présenter brièvement 
son fonctionnement, et plus précisément, les outils qui ont été utiles pour mon stage. Pour comprendre le fonctionnement d'ASP, je me suis servi du guide de ce dernier : \cite{potassco}.
\subsection{Termes}
ASP fonctionne à l'aide de déclarations de faits, de règles, de prédicats contenant un ou plusieurs arguments tels que : \emph{\textcolor{blue}{parentOf(jenny, charles)}}, ce qui nécessite tout d'abord que j'introduise la notion 
de \textbf{terme} (ou \textbf{atome}). On définit un terme de la manière suivante : 
\begin{enumerate}
	\item un terme simple qui peut être :
		\begin{itemize}
		\item un entier relatif (0, -35, 42)
		\item une constante qui démarre par une lettre minuscule(v0us, lis35, quatre, ex3mpl35)
		\item une chaîne de caractères encadrée de guillemets ("ma\_chaine\_de\_caracteres", "42")
		\item une variable grammaticalement identique aux constantes, mais dont la première lettre est majuscule (N0u5, S0mm35, D35, V4r14bl35)
		\item un (ou plusieurs) underscore symbolisant une variable sans nom (\_, \_\_)
		\end{itemize}
	\item une fonction, qu'on appellera également prédicat, est de la forme : constante($t_1$, $t_2$, ..., $t_k$) avec un nombre $k\in\mathbb{N}$ de termes qui sont ses arguments (f(23), im\_function(42, true), me\_too(OUI)).
	Ces fonctions n'ont pas vocation à calculer, mais uniquement à déclarer des objets avec les arguments souhaités comme étant vrais.
	\item un tuple de la forme : ($t_1$, $t_2$, ..., $t_k$) avec un nombre $k\in\mathbb{N}$ de termes ((37, oui), (), (1, f(-4), Var)).
\end{enumerate}

\subsection{Règles et modèles d'un programme}
Un \emph{programme d'ensemble solutions ( = answer set program)} est un nombre fini de règles de la forme :

\begin{center}
$a_0$ :- $a_1,...,a_m,not \: a_{m+1},...,not \: a_n.$
\end{center}
avec $n\geq m\geq 0$. $a_0$ est un atome ou $\bot$ (Bottom/le Faux) et représente ici la \textbf{tête} de la règle. $a_1,...,a_n$ sont des atomes et représentent quant à eux le \textbf{corps} de la règle, et le symbole $"not"$ 
représente la négation par l'échec. Cela signifie que si l'on ne peut pas montrer que $x$ est vrai, alors $not$ $x$ est faux. Cette règle se lit intuitivement : si les atomes $a_1,..,a_m$ sont tous vrais et qu'aucun des atomes 
$a_{m+1},...,a_n$ n'est vrai, alors $a_0$ est vrai.\\ \\
Si $n=m=0$, cela signifie que $a_0$ est vrai. Dans ce cas, on parle d'un fait, et on ne doit pas renseigner ":-". D'une autre part, si $a_0=\bot$, on parle de contrainte : comme $\bot$ ne peut jamais être vrai, si le corps de la 
règle est vrai, cela invalide la solution actuelle. On ne renseigne pas $\bot$ pour la tête, on laisse une tête vide au niveau du code.\\ \\
Cette notion de "solution actuelle" se formalise de la façon suivante : on parle d'une \textbf{interprétation} $I$ en tant qu'ensemble fini d'atomes propositionnels. Une règle $r$ définie comme ci-dessus est \emph{vraie dans I} si 
et seulement si :

\begin{center}
$(\left\{a_1,...,a_m\right\}\subseteq I \wedge \left\{a_{m+1},...,a_n\right\} \cap I = \emptyset) \Rightarrow a_0 \in I$\\
\end{center}
Si toutes les règles d'un programme $P$ sont vraies dans une même interprétation $I$ et que $I$ est minimale, alors on dit que $I$ est un \textbf{modèle} de $P$. Lorsque l'on déclare un problème $P$ en ASP, le solveur nous renverra 
en sortie tout les modèles possibles pour $P$.\\ \\
Je tiens à préciser que les sauts de ligne n'interrompent pas une règle, seul le point la termine.

\subsection{Variables}
Si une variable apparaît dans un atome de la tête, elle doit également être dans le corps. Chaque instance d'une variable va être groundée par ASP afin de trouver tous les modèles à notre problème.
Prenons un exemple, voici un problème encodé avec 2 règles :
\begin{center}
\emph{
	\textcolor{blue}{
  parentOf(jenny, charles).\\
  parentOf(mary, jenny).
	}
}
\end{center}
Ce programme contient 2 faits : Charles est un parent de Jenny, et Jenny est un parent de Mary. C'est ainsi que l'on souhaite comprendre les termes \textcolor{blue}{\emph{parentOf(jenny, charles)}} et 
\textcolor{blue}{\emph{parentOf(mary, jenny)}}.
Si on souhaite désormais spécifier que Charles est grand-père de Mary, on peut le faire en ajoutant le terme : \textcolor{blue}{\emph{grandparentOf(mary, charles)}}. Cependant, ASP est capable de faire de la déduction.
En effet, on peut généraliser la notion de grand-parent comme étant le parent d'un parent de la façon suivante :
\begin{center}
\emph{
	\textcolor{blue}{
  grandparentOf(X, Z) :- parentOf(X, Y), parentOf(Y, Z).
	}
}
\end{center}
Pour chaque valeur possible des variables X, Y, et Z, le grounding d'ASP va nous créer des règles associées.
Ainsi, les 27 règles dont \textcolor{blue}{\emph{grandparentOf(mary, mary) :- parentOf(mary, mary), parentOf(mary, mary)}}, ou encore \textcolor{blue}{\emph{grandparentOf(charles, mary) :- parentOf(charles, jenny), parentOf(jenny, 
mary)}} vont être créées par cette façon de procéder. Ceci n'est pas du tout un problème : le solveur d'ASP va simplement regarder si les atomes des corps sont vraies ou pas.\\
\begin{itemize}
	\item Si c'est le cas pour une règle donnée, la tête de cette dernière sera alors mise à $Vrai$ afin que l'interprétation vérifie bien le plus de règles possible
	\item Si ce n'est pas le cas pour une règle donnée (i.e. l'ensemble des éléments du corps de cette règle est faux), comme $(\bot\Rightarrow x)\Leftrightarrow Vrai$, cette règle sera vraie, que la tête soit mise à $Vrai$ 
	ou pas. Comme l'interprétation doit être de taille minimale, la tête ne sera pas mise à $Vrai$ lors du solving\\
\end{itemize}
Sachant que la seule de ces 27 possibilités possédant un corps vrai est :\\
\textcolor{blue}{\emph{grandparentOf(mary, charles) :- parentOf(mary, jenny), parentOf(jenny, charles)}}, on obtiendra la sortie suivante en ASP :
\begin{center}
\textcolor{blue}{
  SATISFIABLE\\
	\emph{
  parentOf(jenny, charles)\\
  parentOf(mary, jenny)\\
  grandparentOf(mary, charles)
	}
}
\end{center}
\subsection{Agrégats}
Les agrégats forment le dernier outil d'ASP que j'ai utilisé dans le cadre de mon stage. Il s'agit d'un moyen de sélectionner un certain nombre d'atomes parmi un ensemble, et de les mettre à vrai. Ils se 
structurent suivant l'exemple suivant :
\begin{center}
\textcolor{blue}{
  0 $\left\{ coloration(X, Y, Teinte):couleur(Teinte)\right\}$ 1 :- abscisse(X), ordonnee(Y).
}
\end{center}
La \textbf{borne inférieure} située à gauche des accolades (ici 0), et la \textbf{borne supérieure} (ici 1) définissent l'intervalle discret du nombre d'atomes que le solveur peut mettre à vrai. Si l'une de ces deux bornes est 
omise, ASP comprend qu'il s'agit de la borne maximale (ou minimale) possible (à savoir 0 pour la borne inf et cardinal de l'ensemble défini par les accolades pour la borne sup). Dans cet exemple, on choisira donc zéro ou une
couleur parmi celles possibles (telles qu'il existe un atome couleur(Teinte) qui soit $Vrai$) pour chaque abscisse et ordonnée définies.\\
Les agrégats permettent de faire des disjonctions de cas.

\subsection{Premier exemple : le sudoku}
Durant les premières semaines de mon stage, j'ai encodé différents jeux de logique en ASP afin de me familiariser avec le langage. Le jeu le plus simple et connu que j'ai encodé a été le sudoku. Dans cette section, je vais 
briévement détailler le fonctionnement de ce code. La version que je vais présenter est une correction de la mienne, issue du site de Lucas \cite{lucasbourneuf}.\\
On codera une grille de sudoku en ASP en utilisant s, une fonction d'arité 3 prenant X, Y et V comme arguments, où X est la colonne, Y la ligne et V la valeur de la case (X,Y) dans la grille.\\ \\
\emph{
	\textcolor{white}{2c}\% 1..9 est un raccourci pour dire itérer pour les entiers allant de 1 à 9. Ici, on déclare qu'il y a 9 valeurs dans une fonction d'arité 1 : 'val'\\
	1. \textcolor{blue}{$val(1..9)$.}\\
	\textcolor{white}{2c}\% On déclare également 3 autres faits pour mémoriser où sont situés les bordures de notre grille car le point virgule permet de déclarer plusieurs atomes en un\\
	2. \textcolor{blue}{$border(1;4;7)$.}\\
	\textcolor{white}{2c}\% On ne prend qu'une seule valeur par carré\\
	3. \textcolor{blue}{$1\left\{ s(X,Y,V): val(V) \right\}1$ :- $val(X), val(Y)$.}\\
	\textcolor{white}{2c}\% Une valeur ne peut pas apparaître plusieurs fois dans la même colonne\\
	4. \textcolor{blue}{$1\left\{ s(X,Y,V): val(Y) \right\}1$ :- $val(X), val(V)$.}\\
	\textcolor{white}{2c}\% Ni dans la même ligne\\
	5. \textcolor{blue}{$1\left\{ s(X,Y,V): val(X) \right\}1$ :- $val(Y), val(V)$.}\\
	\textcolor{white}{2c}\% Une valeur ne peut pas apparaître plusieurs fois dans une sous-grille.\\
	6. \textcolor{blue}{$1\left\{ s(X,Y,V): val(X), val(Y), X1<=X, X<=(X1+2), Y1<=Y, Y<=(Y1+2)\right\}1$ :-}\\
	7.\qquad\qquad\textcolor{blue}{$val(V), border(X1), border(Y1)$.}\\
}

Une fois que l'on a fait cela, il ne nous reste plus qu'à instancier notre problème sur une grille. Pour cela, on renseigne \emph{\textcolor{blue}{s(X,Y,V)}} pour chaque case déjà pré-numérotée de la grille à notre code, et le 
solveur se chargera de nous renvoyer l'intégralité de la grille complétée. Si une grille possède plusieurs solutions, le solveur retournera toutes les solutions. De plus, si la grille ne possède aucune solution, le solveur renverra 
\emph{\textcolor{blue}{UNSATISFIABLE}}.

\subsection{Scripting Python}
En ASP, on peut écrire des morceaux de script en Lua ou en Python. Pour cela, il suffit d'ajouter la commande '\#script (mon\_langage)', puis de taper son code dans le langage que l'on a choisi, et de finir le script par la 
commande '\#end.'. Le scripting admet trois atouts majeurs :
\begin{itemize}
	\item L'appel aux fonctions en ASP via la commande '@ma\_fonction(et, ses, arguments)', permettant d'effectuer des calculs sous Python et de mettre des variables à vrai en fonction de ce qui a été trouvé dans ces 
	calculs.
	\item Un contrôle de la résolution permettant le filtrage des ensembles solutions, l'ajout de faits/règles, la demande de grounding et de solving. C'est ce dont je me suis le plus servi durant mon stage.
	\item Une méthode incrémentale efficace lorsque l'on a besoin d'avoir une notion de temporalité. Ceci permet d'ajouter un ordre dans le grounding et la résolution des règles.
\end{itemize}

\subsection{Second exemple : le sokoban}
Le sokoban a été le dernier jeu de logique que j'ai encodé en ASP, et le plus complexe à cause de la duplication très couteuse du nombre de coups nécessaires pour la résolution d'une grille.\\

Le jeu est composé d'une grille possédant des cases qui sont du sol ou du mur. Sur une case représentant le sol, il y a le joueur. Sur plusieurs autres cases de sol il y a des caisses. Sur autant de cases de sol qu'il y a de 
caisses, on trouve des cases d'arrivée (qui sont également du sol). Le but du jeu est de pousser toutes les caisses sur les cases d'arrivée sachant que le joueur ne peut se déplacer qu'en haut, à gauche, en bas ou à droite, et ne 
peut pas traverser les murs ni pousser une caisse s'il y a un mur ou une autre caisse derrière celle-ci.\\ \\

\begin{figure}[!h]
	\centering  
	\includegraphics[scale=0.2]{Diagram1.eps}  
	\caption{
			Exemple d'une grille type de sokoban. P symbolise le joueur, les ronds rouges sont les cases d'arrivée, et les carrés rouges représentent les caisses.
	}
	\label{label-figure1}
\end{figure}

En ASP, une grille de sokoban est encodée en spécifiant quelles cases sont des murs, et quelles cases sont des sols avec les prédicats \emph{\textcolor{blue}{mur(X, Y)}} et \emph{\textcolor{blue}{sol(X, Y)}}. On renseigne de plus un 
prédicat \emph{\textcolor{blue}{init(X, Y)}}, ce qui nous donne la position initiale du joueur, et \emph{\textcolor{blue}{caisse\_init(Numero\_caisse, X, Y)}} nous renseignant sur les positions initiales des caisses (le premier 
argument varie de 1 à $n$ lorsque l'on a $n$ de ces caisses). Enfin, le prédicat \emph{\textcolor{blue}{arrivee(X, Y)}} symbolisera une case d'arrivée en \emph{(X, Y)}.\\ \\
J'ai fait différentes versions pour ce jeu. La plus aboutie utilise une méthode incrémentale. Pour l'importer, il nous suffit d'ajouter la commande \emph{\textcolor{blue}{\#include \textless incmode\textgreater.}}. On doit alors 
définir les sous-programmes \textbf{base}, \textbf{step(k)} et \textbf{check(k)}. $k$ est une fausse constante : elle est remplacée à chaque itération par un entier. Par défaut $k$ vaut 0 au début de la résolution, et augmente de 1 
à chaque itération. Dans notre programme, $k$ vaudra 1 initialement.\\
\begin{itemize}
	\item \textbf{base :}\\
		$base$ est le sous-programme qui énonce des règles qui seront toujours à prendre en compte par ASP lors de la résolution (pour tout $k$).\\ \\
		On déclare ici des prédicats \emph{\textcolor{blue}{perso(0, X, Y)}} et \emph{\textcolor{blue}{caisse\_a\_instant(0, X, Y)}} afin de mémoriser la position du joueur à l'étape initiale (0), ainsi que celles des 
		caisses.\\
		\textcolor{magenta}{Pour notre exemple figure \ref{label-figure1}, on aura \emph{perso(0, 2, 5), caisse\_a\_instant(0, 3, 4)}, et \\
		\emph{caisse\_a\_instant(0, 4, 4).}}\\ \\
	\item \textbf{step(k) :}\\
		$step(k)$ est le sous-programme qui va calculer à l'instant $k$ quelles sont les règles à prendre en compte. On en déduira un ensemble $E$ d'atomes tous vrais à l'étape $k$.\\ \\
		On a ici besoin de prédicats \emph{\textcolor{blue}{acces\_a\_instant(k, X, Y)}} pour mémoriser toutes les cases accessibles depuis la position \emph{(X, Y)} de notre joueur à une étape k donnée. Pour déterminer 
		cela, on va mettre des règles pour chaque direction spécifiant que si une case est accessible à une étape $k$ et qu'une des 4 cases voisines à celle-ci est vide (un sol sans caisse) alors cette case voisine est 
		également accessible. On doit également rajouter une règle pour dire que la case sur laquelle se trouve notre personnage à l'étape choisie est accessible (cas initial pour l'induction).\\
		\textcolor{magenta}{Pour notre exemple figure \ref{label-figure1}, toutes les cases de sol ( = vertes) ne possédant pas de caisse sont accessibles. On va donc générer 12 prédicats de la sorte pour l'étape 0.}\\
		On choisit ensuite un coup pour chaque instant à l'aide d'un agrégat. Si à un instant $k$ on a trois cases de sol $c_1$, $c_2$ et $c_3$ alignées horizontalement ou verticalement avec une caisse en $c_2$, l'accès à 
		$c_1$ et pas de caisse en $c_3$, alors le personnage peut se déplacer jusqu'en $c_1$, puis pousser la caisse depuis $c_2$ en $c_3$. On obtient ainsi un coup jouable 
		pour l'instant $k$. L'agrégat nous sélectionne alors un seul de ces coups, qui sera sous la forme d'un prédicat \emph{\textcolor{blue}{coup\_a\_instant(k, (X, Y), (X2, Y2))}}.\\
		\textcolor{magenta}{Dans notre cas figure \ref{label-figure1}, seuls deux coups sont possibles : \emph{coup\_a\_instant(1, (3, 3), (3, 4))} et \\
		\emph{coup\_a\_instant(1, (3, 5), (3, 4)).}}\\
		A partir du choix du coup, on est capable de déduire quelle sera la prochaine case du personnage (celle de la caisse que l'on vient de déplacer), et on peut créer les prédicats 
		\emph{\textcolor{blue}{perso(k, X, Y)}} et \emph{\textcolor{blue}{caisse\_a\_instant(k, X, Y)}} associés à l'instant $k$.\\
		\textcolor{magenta}{Par exemple si l'on a choisi le premier des deux coups jouables, on en déduira les prédicats \emph{perso(1, 3, 4), caisse\_a\_instant(1, 3, 5)}, et \emph{caisse\_a\_instant(1, 4, 4).}}\\
		Enfin, on est capable de savoir si on a résolu la grille ou pas à l'aide d'un prédicat \emph{\textcolor{blue}{caisse\_pas\_place(k)}} qui est vrai s'il reste une ou plusieurs caisses à placer à l'étape $k$.\\
		\textcolor{magenta}{Ici, la caisse en \emph{(3, 5)} n'est pas bien placée à l'étape 1, donc on crée le prédicat \\
		\emph{caisse\_pas\_place(1)}.}\\ \\
	\item \textbf{check(k) :}\\
		$check(k)$ est le sous-programme qui se charge d'arrêter la recherche : si à une étape $k$ ce sous-programme est satisfiable par les éléments de $E$, alors le programme s'arrêtera et renverra l'ensemble solution 
		courant.\\ \\
		Pour vérifier si l'on a trouvé une solution à notre grille, il suffit simplement d'ajouter une contrainte \emph{\textcolor{blue}{:- caisse\_pas\_place(k)}}. En effet, s'il existe une caisse non placée le 
		$check(k)$ ne sera pas satisfiable.\\
		\textcolor{magenta}{Dans notre exemple, le coup de caisse qu'on a choisi fait peut-être avancer la résolution, mais ne l'a pas achevée.}\\
\end{itemize}
On récupère alors l'ensemble des coups de caisses à faire, et on peut résoudre notre grille en comblant les coups qui déplaçaient les caisses par ceux nécessaires pour atteindre la prochaine caisse à déplacer.\\
\textcolor{magenta}{Pour l'exemple figure \ref{label-figure1}, ASP nous renvoie l'ensemble des coups suivant : s(1, (3, 5), bas), s(2, (5, 4), gauche), s(3, (4, 4), gauche), s(4, (2, 5), bas), s(5, (3, 2), haut), s(6, (2, 4), 
droite), s(7, (2, 2), haut). \emph{s(k, case, direction)} signifie que le personnage peut aller à l'instant $k$ à la case indiquée, et pousser une caisse dans la direction indiquée.}

\section{Formalismes d'automates et leur dynamique}
\label{fad}
Différents modèles existent pour représenter efficacement un système biologique et manipuler sa dynamique : les deux principaux sont les réseaux booléens synchrones de Stuart \cite{kauffman1969metabolic}, et les réseaux 
asynchrones de René \cite{thomas1973boolean}.
Dans le cadre de mon stage je ne parlerai que des réseaux asynchrones, et plus particulièrement des réseaux d'automates asynchrone (AAN) \cite{folschette2015sufficient} et \cite{pauleve2016pint}, qui forment une extension d'une 
précédente structure appelée "Process Hitting" \cite{pauleve14}.\\

\subsection{AAN et leur traduction en ASP}
Un automate $A$, dans le contexte de mon stage, sera défini comme étant un ensemble d'états $q_0, q_1, ..., q_{|A|-1}$ avec des transitions dont les étiquettes seront un ou plusieurs états (qu'on appellera également \emph{niveaux}) 
d'automates externes. Il n'y a donc ni état final, ni état initial. On ne lui donnera pas non plus de mot à lire en entrée puisqu'on va s'intéresser à la dynamique de nos ensembles d'automates. On parlera alors de 
transition locale : $q_i\xrightarrow{l}q_j$ symbolisera le fait que l'on peut passer de l'état $q_i$ à l'état $q_j$ si toutes les conditions de $l$ sont vérifiées.\\
Un réseau d'automates asynchrone est un triplet $(\Sigma,S,T)$ avec :
\begin{itemize}
	\item $\Sigma=\left\{a,b,...\right\}$ est un ensemble fini d'automates non vides.
	\item Si $C_a$ est le nombre d'états d'un automate $a$, alors $S_a=\left\{a_0,a_1,...,a_{C_a-1}\right\}$ est l'ensemble des \textbf{états locaux} de l'automate $a$. $S=\displaystyle{\prod_{a\in\Sigma}}S_a$ est l'ensemble 
	fini des \textbf{états globaux}, et $LS=\displaystyle{\bigcup_{a\in\Sigma}}S_a$ représente l'ensemble de tous les états locaux.
	\item Pour chaque $a\in\Sigma$, $T_a\subseteq\left\{a_i\xrightarrow{l}a_j\in S_a\times\rho(LS/S_a)\times S_a|a_i\neq a_j\right\}$ est l'ensemble des \textbf{transitions locales} d'un automate $a$, avec 
	$\rho$ qui désigne la puissance ensembliste. $T=\displaystyle{\bigcup_{a\in\Sigma}}T_a$ est l'ensemble des transitions locales du modèle.\\ \\
\end{itemize}
\hypertarget{exemple}{\textbf{Exemple :}} On représente l'AAN suivant de cette manière :
\begin{itemize}
	\item $\Sigma =\left\{a,b,c\right\}$
	\item $S_a=\left\{a_0,a_1,a_2\right\}$, $S_b=\left\{b_0,b_1\right\}$ et $S_c=\left\{c_0,c_1,c_2\right\}$
	\item $T_a = \left\{a_0\xrightarrow{b_0}a_1,a_0\xrightarrow{b_1,c_1}a_1,a_1\xrightarrow{b_1}a_0,a_1\xrightarrow{b_0}a_2,a_2\xrightarrow{b_1}a_1\right\}$\\
	$T_b=\left\{b_0\xrightarrow{c_0}b_1,b_1\xrightarrow{a_2}b_0\right\}$\\
	$T_c=\left\{c_0\xrightarrow{b_1}c_1,c_0\xrightarrow{a_2}c_2,c_1\xrightarrow{b_0}c_0,c_1\xrightarrow{a_1}c_2,c_2\xrightarrow{b_1}c_0\right\}$
\end{itemize}

\begin{figure}[!h]
	\centering  
	\begin{tikzpicture}[apdotsimple/.style={apdot}]
	  \TSort{(0,2)}{a}{3}{r}
	  \TSort{(2.5,0)}{b}{2}{r}
	  \TSort{(5,2)}{c}{3}{r}

	  \path[local transitions]
	    (a_0) edge node[auto] {$b_0$} (a_1)
	    (a_1) edge node[auto] {$b_0$} (a_2)
	    (a_2) edge node[auto] {$b_1$} (a_1)
	    (a_1) edge node[auto] {$b_1$} (a_0)

	    (b_0) edge node[auto] {$c_0$} (b_1)
	    (b_1) edge node[auto] {$a_2$} (b_0)

	    (c_0) edge node[auto] {$b_1$} (c_1)
	    (c_1) edge node[auto] {$b_0$} (c_0)
	    (c_1) edge node[auto] {$a_1$} (c_2)
	    ;
	  \path[local transitions, bend left = 105]
	      (a_0) edge node[auto] {$b_1, c_1$} (a_1)
	    ;
	  \path[local transitions, bend left = 90]
	      (c_0) edge node[auto] {$a_2$} (c_2)
	    ;
	  \path[local transitions, bend left = 90]
	      (c_2) edge node[auto] {$b_1$} (c_0)
	    ;

	  \TState{a_0, b_1, c_1}
	\end{tikzpicture}
	
	\caption{Exemple de réseau d'automates asynchrone}
	\label{label-figure2}
\end{figure}



En ASP, on définira un AAN en deux temps :
\begin{itemize}
	\item On commencera par déclarer chacun de nos automates avec les niveaux (= états) qu'il contient :\\
	\emph{
		\textcolor{blue}{
		automaton\_level("a", 0..2).\\
		automaton\_level("b", 0..1).\\
		automaton\_level("c", 0..2).\\
		}
	}
	\item Enfin, les transitions seront encodées via des labels (t1, t2, ...), et on donnera chacune des conditions, ainsi que l'état d'arrivée, via un fait :\\
	\emph{
		\textcolor{blue}{
		condition(t1, "a", 0). target(t1, "a", 1). condition(t1, "b", 0).\\
		condition(t2, "a", 1). target(t2, "a", 2). condition(t2, "b", 0).\\
		condition(t3, "a", 2). target(t3, "a", 1). condition(t3, "b", 1).\\
		condition(t4, "a", 1). target(t4, "a", 0). condition(t4, "b", 1).\\
		\verb![...]!\\
		condition(t12, "a", 0). target(t12, "a", 1). condition(t12, "b", 1). condition(t12, "c", 1).\\
		}
	}
\end{itemize}
Nous avons ainsi défini l'automate de notre \hyperlink{exemple}{\textbf{exemple}} en ASP.

\subsection{Sémantiques}
\hypertarget{semantiques}{Soit $R = (\Sigma,S,T)$ un AAN (défini ci-dessus). On définit la notion de transition jouable:}
\begin{itemize}
	\item On dit qu'une transition locale est \textbf{jouable} si toutes les conditions de celle-ci sont vérifiées.\\
	On notera $P_{\zeta}$ l'ensemble des transitions locales jouables depuis un état global $\zeta$.\\
	\emph{L'état global $(a_0,b_1,c_1)$ de l'\hyperlink{exemple}{\textbf{exemple}} admet une seule transition jouable : $a_0\xrightarrow{b_1,c_1} a_1$.}
\end{itemize}
La dynamique d'un AAN se définit à l'aide de sa \textbf{sémantique}. La sémantique forme l'ensemble des propriétés définissant les \textbf{transitions globales jouables} : dans un AAN on s'intéresse à l'évolution globale du réseau.
\subsubsection{Asynchrone}
Soit $R = (\Sigma,S,T)$ un AAN, et $\zeta\in S$ un état global. L'ensemble des transitions globales jouables depuis $\zeta$ pour la sémantique \emph{asynchrone} est donné par :
\begin{center}
	$U^{asyn}(\zeta)=\left\{\left\{a_i\xrightarrow{l} a_j\right\}|a_i\xrightarrow{l} a_j\in P_{\zeta}\right\}$
\end{center}
De manière informelle : chaque transition locale jouable est une transition globale.\\ \\
En ASP, on définit préalablement les états globaux à l'aide d'un prédicat de la forme \emph{\textcolor{blue}{global\_state(Gs)}} avec $Gs$ qui s'écrit en ASP à l'aide d'une constante unique (g1\_1\_0 symbolisera par exemple que 
l'on est dans l'état global (1,1,0), cf \hyperlink{partie4.4}{Partie 4.4}). On peut ensuite déclarer que deux états globaux sont différents sur un automate à l'aide de la règle suivante :\\
\emph{
1. \textcolor{blue}{different\_on(Gs1, Gs2, Automaton) :-} \% Automaton n'a pas le même état actif dans $Gs1$ et $Gs2$\\
2.\qquad \textcolor{blue}{global\_state(Gs1), global\_state(Gs2), Gs1 != Gs2,} \% si deux états globaux diffèrent\\
3.\qquad \textcolor{blue}{automaton(Automaton),} \% qu'il existe un automate\\
4.\qquad \textcolor{blue}{active\_in\_g(level(Automaton, LevelI), Gs1),} \% sur lequel $Gs1$ vaut $I$\\
5.\qquad \textcolor{blue}{active\_in\_g(level(Automaton, LevelJ), Gs2),} \% et sur lequel $Gs2$ vaut $J$\\
6.\qquad \textcolor{blue}{LevelI != LevelJ.} \% avec $I \neq J$\\ \\
}
Ensuite, on fait comprendre à ASP qu'une transition locale n'est pas jouable si l'une (au moins) de ses conditions n'est pas vérifiée de la façon suivante :\\
\emph{
1. \textcolor{blue}{unplayable(Transition, Gs) :-} \% une transition n'est pas jouable depuis Gs1\\
2.\qquad \textcolor{blue}{local\_transition(Transition),} \% si elle est locale,\\
3.\qquad \textcolor{blue}{global\_state(Gs),} \% s'il existe un état global\\
4.\qquad \textcolor{blue}{automaton(Automaton),} \% et un automate\\
5.\qquad \textcolor{blue}{active\_in\_g(level(Automaton, LevelI), Gs),} \% sur lequel $Gs$ vaut $I$\\
6.\qquad \textcolor{blue}{condition(Transition, Automaton, LevelJ),} \% alors qu'il devrait valoir $J\neq I$\\
7.\qquad \textcolor{blue}{LevelI != LevelJ.} \% pour que Transition soit jouable\\ \\
}
On déclare ensuite que deux états globaux diffèrent sur au moins un autre automate qu'$Automaton$ avec le terme $not\_equal\_except(Automaton, Gs1, Gs2)$ comme ceci :\\
\emph{
1. \textcolor{blue}{not\_equal\_except(Automaton, Gs1, Gs2) :-} \% $Gs1$ et $Gs2$ diffèrent d'au moins 1 autre automate qu'Automaton \\
2.\qquad \textcolor{blue}{automaton(Automaton), automaton(Automaton2),} \% s'il existe deux automates\\
3.\qquad \textcolor{blue}{Automaton != Automaton2,} \% qui différent,\\
4.\qquad \textcolor{blue}{global\_state(Gs1), global\_state(Gs2),} \% deux états globaux\\
5.\qquad \textcolor{blue}{different\_on(Gs1, Gs2, Automaton2).} \% tels que $Gs1 \neq Gs2$ sur Automaton2\\ \\
}
On peut enfin définir ce qu'est une transition globale jouable à l'aide de nos trois précédentes règles :\\
\emph{
1. \textcolor{blue}{playable(Gs1, Gs2) :-} \% On peut aller depuis $Gs1$ en $Gs2$\\
2.\qquad \textcolor{blue}{global\_state(Gs1), global\_state(Gs2),} \% s'il existe deux états globaux $Gs1$ et $Gs2$\\
3.\qquad \textcolor{blue}{automaton(Automaton), local\_transition(Transition),} \% un automate et une transition\\
4.\qquad \textcolor{blue}{target(Transition, Automaton, LevelJ),} \% qui fait changer le niveau de l'automate\\
5.\qquad \textcolor{blue}{not unplayable(Transition, Gs1),} \% et avec la transition (locale) qui est jouable\\
6.\qquad \textcolor{blue}{not not\_equal\_except(Automaton, Gs1, Gs2),} \% et $Gs1=Gs2$ excepté sur Automaton\\
7.\qquad \textcolor{blue}{active\_in\_g(level(Automaton, LevelI), Gs1),} \% tel que le niveau d'$Automaton$ dans $Gs1$\\
8.\qquad \textcolor{blue}{active\_in\_g(level(Automaton, LevelJ), Gs2),} \% et celui dans $Gs2$\\
9.\qquad \textcolor{blue}{LevelI != LevelJ.} \% sont différents\\
}
\subsubsection{Synchrone}
Soit $R = (\Sigma,S,T)$ un AAN, et $\zeta\in S$ un état global. L'ensemble des transitions globales jouables depuis $\zeta$ pour la sémantique \emph{synchrone} est donné par :
\begin{center}
	$U^{syn}(\zeta)=\left\{u\subseteq T|u \neq \emptyset \wedge \forall a\in\Sigma,(P_{\zeta}\bigcap T_a = \emptyset \Rightarrow u\bigcap 
	T_a=\emptyset)\wedge(P_{\zeta}\bigcap T_a\neq\emptyset\Rightarrow |u\bigcap T_a |=1\right\}$
\end{center}
De manière informelle : tous les automates possédant au moins une transition locale jouable doivent changer de niveau.\\ \\
Pour coder cela en ASP, on peut se servir des atomes \emph{\textcolor{blue}{different\_on}} et \emph{\textcolor{blue}{unplayable}}.\\
On ajoute de plus une autre règle : \emph{\textcolor{blue}{has\_playable(Automaton, Gs, LevelI, LevelJ)}} spécifiant que l'on peut faire changer $Automaton$ dans $Gs$ du niveau $I$ vers le niveau $J$.\\
Enfin, il ne nous reste plus qu'à déclarer (par la négation) quelles sont les transitions globales qui ne sont pas jouables. Pour cela, on essaie pour toutes les paires d'états globaux si on peut faire la transition de l'un à 
l'autre en créant un terme \emph{\textcolor{blue}{not\_playable(Gs1,Gs2)}} si la transition ne peut pas avoir lieu. On énumère alors les différents cas de figure :
\begin{enumerate}
	\item si $Automaton$ n'admet aucune transition locale jouable dans $Gs_1$ et que $Gs_1\neq Gs_2$ sur $Automaton$
	\item si $Automaton$ admet une (ou plusieurs) transition locale jouable dans $Gs_1$ et qu'il n'existe pas de transition pour faire passer le niveau d'$Automaton$ sur $Gs_1$ à celui de $Gs_2$
	\item si aucune transition locale n'est jouable depuis $Gs_1$
\end{enumerate}
alors la transition $Gs_1\rightarrow Gs_2$ n'est pas jouable.\\
Enfin, il nous suffit de tester pour toutes les paires d'états globaux distincts si on a \emph{\textcolor{blue}{not\_playable(Gs1,Gs2)}} ou pas. Dans le cas contraire, alors on crée l'atome 
\emph{\textcolor{blue}{playable(Gs1,Gs2)}}.\\
Je n'ai pas mis le code de cette sémantique puisqu'il est trop long.

\subsubsection{Généralisée}
Soit $R = (\Sigma,S,T)$ un AAN, et $\zeta\in S$ un état global. L'ensemble des transitions globales jouables depuis $\zeta$ pour la sémantique \emph{généralisée} est donné par :
\begin{center}
	$U^{gen}(\zeta)=\left\{u\subseteq T|u \neq \emptyset \wedge \forall a\in\Sigma,(P_{\zeta}\bigcap T_a = \emptyset \Rightarrow u\bigcap 
	T_a=\emptyset)\wedge(P_{\zeta}\bigcap T_a\neq\emptyset\Rightarrow |u\bigcap T_a |\leq 1\right\}$
\end{center}
De manière informelle : tous les automates possédant au moins une transition locale jouable \underline{peuvent} changer de niveau, et au moins l'un d'entre eux doit changer de niveau.\\ \\
Pour coder cela en ASP, on prend exactement le code de la sémantique synchrone, en remplaçant le second cas de figure par ceci :\\ \\
\textcolor{white}{4cha}2. si $Gs_1$ diffère de $Gs_2$ sur $Automaton$ et qu'il n'existe pas de transition pour faire passer 
\textcolor{white}{6chara}le niveau d'$Automaton$ sur $Gs_1$ à celui de $Gs_2$\\ \\
Cela permet bien de ne pas prendre une transition par automate qui est jouable puisqu'on va tester des paires d'états globaux qui ont peut-être 3 automates jouables, et si l'on ne fait qu'une seule transition locale cela ne sera pas 
filtré par notre atome \emph{\textcolor{blue}{not\_playable(Gs1,Gs2)}}.\\
Je n'ai pas mis le code de cette sémantique puisqu'il est trop long.

\subsection{Dynamique}
Soit $U$ une sémantique. On introduit les dernières notions nécessaires pour la définition d'un attracteur :
\begin{itemize}
	\item On appelle \textbf{état stable} un état global ne possédant aucune transition globale jouable pour $U$.
	\emph{Dans l'\textbf{exemple}, aucun état global n'est stable pour la sémantique asynchrone (et donc cela est également vrai pour la sémantique synchrone et généralisée).}
	\item Pour $Gs_1,Gs_2\in S$, on notera $Gs_1\rightarrow _UGs_2$ pour symboliser le fait qu'il existe $u\in U(Gs_1)$ tel que si l'on joue toutes les transitions locales de $u$, alors $Gs_1$ devient $Gs_2$.
	\item Un \textbf{chemin} est une famille finie $(A_k)_{1\leq k\leq n}$ et ordonnée d'états globaux tels que pour tout $1\leq k\leq n-1$, $A_k\rightarrow _U A_{k+1}$.
	\item Un \textbf{cycle} est un chemin $(A_k)_{1\leq k\leq n}$ tel que $A_1=A_n$.
	\item Un \textbf{domaine de piège} est un ensemble non vide d'états globaux $S_E\in S$ tel que toute transition globale jouable depuis $S_E$ arrive dans un état global de $S_E$. Plus formellement : 
	$\forall\zeta _1\in S_E \wedge\forall\zeta _2\in S, \zeta _1 \rightarrow _U\zeta _2 \Rightarrow\zeta _2\in S_E$
\end{itemize}
Enfin, on peut définir ce qu'est un attracteur.\\
Un ensemble $A\subseteq S$ d'états globaux, avec $|A|\geq2$ est appellé \textbf{attracteur} si et seulement si c'est un domaine de piège minimal en terme d'inclusion ensembliste.\\
\cite{chapitre} a démontré le résultat mathématique suivant dont on va se servir pour trouver les attracteurs au sein d'un AAN :\\ \\
\textbf{Lemme :} Les attracteurs d'un AAN sont exactement les domaines de piège cycliques.

\section{Cœur de la contribution personnelle}
\label{ccp}
\hypertarget{debutpartie4}{
J'ai tout d'abord étudié la version existante du code afin de la comprendre et d'essayer de corriger l'erreur qu'elle contenait. Cette version était fonctionnelle et efficace pour la sémantique asynchrone, mais ne fonctionnait pour 
la sémantique synchrone que lorsque les attracteurs étaient exactement des cycles simples (chaque état global du graphe produit doit avoir un degré sortant égal à $1$), et ne fonctionnait pas pour les autres AAN comme 
celui figure \ref{label-figure3}, dont le graphe produit est représenté figure \ref{label-figure4}.\\ \\ \\
}

\begin{figure}[!h]
	\centering  
	\begin{tikzpicture}[apdotsimple/.style={apdot}]

	  \TSort{(0,2)}{a}{3}{r}
	  \TSort{(3,2)}{b}{3}{r}

	  \path[local transitions]
	    (a_0) edge node[auto] {$b_0$} (a_1)
	    (a_1) edge node[auto] {$b_1$} (a_2)
	    (a_2) edge node[auto] {$b_1$} (a_1)

	    (b_0) edge node[auto] {$a_0$} (b_1)
	    (b_1) edge node[auto] {$a_1$} (b_2)
	    (b_2) edge node[auto] {$a_1$} (b_1)
	    ;
	    
	    \path[local transitions, bend left = 90]
	      (a_0) edge node[auto] {$b_0$} (a_2)
	    ;
	    \path[local transitions, bend left = 90]
	      (a_2) edge node[auto] {$b_2$} (a_0)
	    ;
	    \path[local transitions, bend left = 90]
	      (b_0) edge node[auto] {$a_0$} (b_2)
	    ;
	    \path[local transitions, bend left = 90]
	      (b_2) edge node[auto] {$a_2$} (b_0)
	    ;
	\end{tikzpicture} 
	\caption{Exemple d'AAN sur lequel le code pré-existant ne trouvait pas l'attracteur}
	\label{label-figure3}
\end{figure}

\begin{figure}[!h]
	\centering  
	\includegraphics[scale=0.3]{Diagram2.eps}  
	\caption{Graphe produit de l'AAN figure \ref{label-figure3} pour la sémantique synchrone}
	\label{label-figure4}
\end{figure}

En effet, l'ensemble $\left\{(0,0),(1,1),(1,2),(2,1),(2,2)\right\}$ est un attracteur de cet AAN pour la sémantique synchrone. De plus, il existe deux (même quatre ici) transitions globales jouables depuis l'état global $(0,0)$ : 
on peut aller en $(1,1)$ ou encore en $(2,2)$.\\ \\
Après avoir identifié le problème au sein du code, j'ai trouvé deux alternatives pour corriger cela : la première consiste à reprendre tout le code, enlever le problème ciblé et corriger cela avec un script Python, et la seconde 
consiste à considérer les états globaux et à définir les transitions globales jouables dans des fichiers dédiés aux sémantiques. Je vais donc détailler deux manières de trouver les attracteurs d'un AAN en ASP.

\subsection{Code pré-existant}
\hypertarget{preexistante}{On explique tout d'abord comment générer des chemins d'une longueur définie dans un AAN.}\\ \\
\emph{
	\% On mémorise quelques informations : noms des automates et des transitions locales\\
	1. \textcolor{blue}{automaton(Automaton) :- automaton\_level(Automaton, \_).}\\
	2. \textcolor{blue}{local\_transition(Transition, Automaton) :- target(Transition, Automaton, \_).}\\
	3. \textcolor{blue}{local\_transition(Transition) :- target(Transition, \_, \_).}\\ \\
	\% On définit ensuite les étapes de notre chemin\\
	4. \textcolor{blue}{step(0..n).} \% Ici n est une constante qu'on définit lors de la compilation (souvent 10)\\
	5. \textcolor{blue}{1 \{main\_cycle\_length(N) : step(N), N \textgreater 0 \} 1.}\% La longueur du cycle principal\\
	6. \textcolor{blue}{cycle\_step(0..N) :- main\_cycle\_length(N).}\% On nomme les étapes du cycle principal\\
	7. \textcolor{blue}{after\_cycle\_step(N+1..n) :- main\_cycle\_length(N).}\% différemment de celles d'après\\ \\
	\% On choisit ensuite un état initial à l'aide d'un agrégat\\
	8. \textcolor{blue}{1 \{ active(level(Automaton, Level), 0) : automaton\_level(Automaton, Level) \} 1 :-}\\
	9.\qquad\qquad\textcolor{blue}{automaton(Automaton).}\\ \\
	\% On calcule les transitions locales non jouables pour chaque étape\\
	10. \textcolor{blue}{unplayable(Transition, Step) :-}\\
	11.\qquad\qquad\textcolor{blue}{active(level(Automaton, LevelI), Step),}\\
	12.\qquad\qquad\textcolor{blue}{condition(Transition, Automaton, LevelJ),}\\
	13.\qquad\qquad\textcolor{blue}{LevelI != LevelJ, step(Step).}\\ \\
	\% On trouve les automates qui ont au moins une transition jouable (sémantique synchrone)\\
	14. \textcolor{blue}{has\_playable(Automaton, Step) :-}\\
	15.\qquad\qquad\textcolor{blue}{not unplayable(Transition, Step),}\\
	16.\qquad\qquad\textcolor{blue}{local\_transition(Transition, Automaton),}\\
	17.\qquad\qquad\textcolor{blue}{step(Step).}\\ \\
	\% On sélectionne une transition à jouer pour chaque automate si possible\\
	18. \textcolor{blue}{1 \{played(Transition, Step) :}\\
	19.\qquad\qquad\textcolor{blue}{not unplayable(Transition, Step),}\\
	20.\qquad\qquad\textcolor{blue}{local\_transition(Transition, Automaton)}\\
	21. \textcolor{blue}{\} 1 :- has\_playable(Automaton, Step).}\\ \\
	\% Contrainte : on doit jouer au moins une transition locale à chaque étape\\
	22. \textcolor{blue}{:- 0 \{ played(\_, Step) \} 0, step(Step).}\\ \\
	\% Maintenant que l'on a choisi notre coup, on en déduit le changement à faire.\\
	23. \textcolor{blue}{change(Transition, Automaton, LevelI, LevelJ, Step) :-}\\
	24.\qquad\qquad\textcolor{blue}{played(Transition, Step),}\\
	25.\qquad\qquad\textcolor{blue}{target(Transition, Automaton, LevelJ),}\\
	26.\qquad\qquad\textcolor{blue}{condition(Transition, Automaton, LevelI).}\\ \\
	\% On change le niveau actif s'il y a un changement dans Automaton\\
	27. \textcolor{blue}{active(level(Automaton, LevelK), Step + 1) :-}\\
	28.\qquad\qquad\textcolor{blue}{change(\_, Automaton, \_, LevelK, Step),}\\
	29.\qquad\qquad\textcolor{blue}{Step \textless n.}\\ \\
	\% On garde le niveau actif s'il n'y a pas de changement dans Automaton\\
	30. \textcolor{blue}{active(level(Automaton, LevelK), Step + 1) :-}\\
	31.\qquad\qquad\textcolor{blue}{not change(\_, Automaton, \_, \_, Step),}\\
	32.\qquad\qquad\textcolor{blue}{active(level(Automaton, LevelK), Step),}\\
	33.\qquad\qquad\textcolor{blue}{step(Step), Step \textless n.}\\ \\
}
Je viens ici d'expliquer comment faire pour générer tous les chemins de longueur $n$ avec la sémantique synchrone. Cependant, pour qu'un de ses chemins nous intéresse, il faut qu'il respecte les 3 contraintes suivantes :\\
\begin{itemize}
	\item avoir un cycle de longueur N (lorsque \emph{\textcolor{blue}{main\_cycle\_length(N)}} est vrai)
	\item tout les états globaux du chemin visités après l'étape N (lorsque \emph{\textcolor{blue}{main\_cycle\_length(N)}} est vrai) doivent être des éléments du cycle
	\item toutes les transitions globales jouables depuis chacun des éléments du cycle doivent arriver dans un autre élément de ce cycle ( = domaine piège)\\
\end{itemize}
Les deux premières conditions se vérifient assez aisèment.\\ \\
Pour la première, on crée un prédicat \textcolor{blue}{\emph{different\_states\_on(Step1, Step2, Automaton)}} nous permettant de déduire si deux états globaux atteints à $Step_1$ et $Step_2$ sont différents ou pas. On en déduit 
alors un prédicat \textcolor{blue}{\emph{same\_state(Step1, Step2)}}, et il ne nous reste qu'à ajouter la contrainte \textcolor{blue}{\emph{:- not same\_state(0, N), main\_cycle\_length(N).}}\\ \\
Quant à la seconde, il nous suffit de créer un prédicat \textcolor{blue}{\emph{valid\_state\_after\_main\_cycle(Step2)}} vrai lorsqu'il existe une étape $Step_1$ dans le cycle principal et une étape $Step_2$ en dehors du cycle 
principal telles que l'on ait l'atome \textcolor{blue}{\emph{same\_state(Step1, Step2)}} qui soit vrai. Ce prédicat devant être toujours vrai pour chaque $Step_2$, on rajoute finalement la contrainte suivante :\\
\textcolor{blue}{\emph{:- not valid\_state\_after\_main\_cycle(Step1), after\_cycle\_step(Step1).}}\\ \\
La troisième contrainte contenait la raison du bug du code (cf début \hyperlink{debutpartie4}{partie 4}). Comme la modélisation actuelle des choses ne mémorise pas quels sont les coups jouables pour la sémantique choisie 
(cela permettait d'avoir un code qui fonctionne pour toutes les sémantiques en scindant le fichier ASP en deux : recherche des attracteurs, et sémantique, ce qui permettait d'avoir un seul solveur d'attracteur, universel 
pour toutes les sémantiques), cela n'était pas possible. Deux options étaient alors envisageables pour résoudre ce problème : faire un script ASP dans laquelle je rajoute la dernière contrainte en introduisant une notion d'état 
global ; ou bien utiliser Python pour résoudre ce problème lors du solving de clingo.

\subsection{Résolution de la troisième contrainte en Python}
Je ne vais pas rentrer en détail dans la manière dont on peut réussir à récupérer des atomes lors du grounding et du solving d'ASP en Python : on admettra que cela est faisable. Nous avons donc en Python une 
\textcolor{blue}{\emph{boucle for}} qui va, à chaque itération, avoir un ensemble d'atomes tous vrais tel que l'interprétation qu'ils forment satisfasse toutes les règles de notre programme ASP.\\ \\
Lors de la première itération de cette boucle, il est nécessaire de mémoriser toutes les transitions, les conditions, ainsi que les cibles de ces transitions. On introduit donc quelques ensembles pour stocker cela en mémoire.\\ \\
\emph{
	1. \textcolor{blue}{condition\_transitions = \{\}} \# de la forme [transition][automata] = level\\
	2. \textcolor{blue}{target\_transitions\_automaton\_name = \{\}} \# de la forme [transition] = automaton\_name\\
	3. \textcolor{blue}{target\_transitions\_automaton\_level = \{\}}  \# de la forme [transition] = level\\
	4. \textcolor{blue}{transitions\_already\_done = False}\\ \\
}
Ensuite, dès le début de la \emph{\textcolor{blue}{boucle for}} magique, on récupère toutes les informations nécessaires pour remplir ces ensembles, et on modifie la variable booléenne \emph{\textcolor{blue}
{transitions\_already\_done}} à True afin de ne plus faire cela lors des autres itérations de la boucle.\\
On en profite également pour créer un ensemble \emph{\textcolor{blue}{cur\_set}}  de la forme \emph{\textcolor{blue}{[step\_number][automata\_name] = active\_level}} qui viendra mémoriser les états globaux de chaque étape de 
l'ensemble solution courant.\\ \\
Ensuite, on crée un dictionnaire \emph{\textcolor{blue}{playable}} qu'on va venir remplir avec les transitions locales jouables depuis chacun des états globaux de l'attracteur courant et chaque automate de ce dernier. Il est de la 
forme \\
\emph{\textcolor{blue}{playable[global\_state][automata\_name][transition] = level}} où 'level' est le niveau de l'automate après la transition. Pour remplir ce dernier, il faut qu'on teste pour chaque transition locale si elle est 
jouable pour l'état global courant ou pas en regardant pour chaque condition de la transition si elle est vérifiée ou pas. Si elle est bien jouable, on l'ajoute au dictionnaire.\\ \\
On se sert du dictionnaire \emph{\textcolor{blue}{playable}} pour créer une liste de listes de listes d'entiers \emph{\textcolor{blue}{list\_of\_list}}. Pour faire simple, chacune de ses sous-listes représente un état global de 
l'attracteur courant. Chacune des sous-listes de ces états globaux représente un automate, et chacune des sous-listes de cet automate correspond à l'ensemble des niveaux dans lesquels il peut se retrouver après une transition locale 
jouable depuis l'état global. Si aucune transition locale n'est jouable, la sous-liste de l'automate en question sera vide. Pour remplir cette liste, on procède de la façon suivante :\\
\begin{itemize}
	\item Pour chaque état global de l'attracteur courant on crée une liste \emph{\textcolor{blue}{list\_for\_current\_state}} (des automates)
	\item Pour chaque automate de cet état global on crée une liste \emph{\textcolor{blue}{list\_for\_automaton}}(des niveaux atteignables)
	\item Si aucune transition locale n'est jouable pour l'automate, on le laisse à son niveau
	\item Sinon pour chaque transition locale jouable on détermine le niveau après transition de l'automate et on l'ajoute à la liste des niveaux atteignables de l'automate
	\item on ajoute la liste des niveaux atteignables de l'automate à l'état global, puis la liste de l'état global à \emph{\textcolor{blue}{list\_of\_list}}\\
\end{itemize}
L'utilisation d'une liste de listes est très pratique puisqu'il nous suffit alors d'effectuer un produit cartésien de listes pour en déduire les listes de tout les états globaux atteignables depuis notre attracteur courant. C'est 
exactement ce qu'on calcule dans \emph{\textcolor{blue}{list\_of\_product}} : la liste des produits cartésiens de chaque coup possible pour un état global.\\ \\
Enfin, il nous suffit de vérifier que chaque élément de list\_of\_product est bien un élément du cycle principal. De cette façon, notre attracteur vérifiera bien la troisième condition, et sera valide.
Si un au moins des éléments de \emph{\textcolor{blue}{list\_of\_product}} n'est pas dans l'attracteur, alors il ne s'agit en réalité pas d'un attracteur : on peut s'en échapper.\\ \\
C'est ici que l'on termine la \emph{\textcolor{blue}{boucle for}} magique.\\ \\
Les résultats de cette version sont plus qu'appréciables. En effet, j'ai utilisé la même batterie de tests que Maxime Folschette pour la version de laquelle je suis parti, et les durées de résolution se sont avérées toutes aussi 
bonnes que celles de la sémantique asynchrone.

\subsection{Légère modification pour sémantique généralisée}
En reprenant le code présenté ci-dessus, j'ai également fait une version pour la sémantique généralisée (la version de laquelle je suis parti fonctionnant très bien pour la sémantique asynchrone, je n'ai rien à dire 
dessus). En effet, la différence avec la sémantique synchrone est que l'on peut faire changer nos automates ou pas, mais qu'au moins un de tous les automates doit changer de niveau lorsque l'on recherche quelles sont les 
transitions globales jouables.
Concrètement, il faut modifier la sémantique dans le code pré-existant en ASP:\\ \\
\emph{
	\textcolor{blue}{\verb![...]!}\\
	\% On sélectionne \underline{0 ou 1} transition à jouer pour chaque automate\\
	18. \textcolor{blue}{\textcolor{red}{0} \{played(Transition, Step) :}\\
	19.\qquad\qquad\textcolor{blue}{not unplayable(Transition, Step),}\\
	20.\qquad\qquad\textcolor{blue}{local\_transition(Transition, Automaton)}\\
	21. \textcolor{blue}{\} 1 :- has\_playable(Automaton, Step).}\\
	\textcolor{blue}{\verb![...]!}\\ \\
}
On doit ensuite modifier dans le code python le fait que \emph{\textcolor{blue}{list\_for\_automaton}} soit initialement vide : pour chaque automate, on peut soit rester dans cet automate, soit faire une des transitions trouvées. 
On va donc initialiser cette liste de cette façon :\\
\emph{\textcolor{blue}{list\_for\_automaton = [global\_state[sorted\_automata\_names.index(automaton\_name)]]}} (où \\
\emph{\textcolor{blue}{sorted\_automata\_names}} est une liste des noms d'automates triée par ordre lexicographique). Ensuite, on rajoute à \emph{\textcolor{blue}{list\_for\_automaton}} tous les autres niveaux atteignables pour 
l'état global courant (tout comme la sémantique synchrone).

\subsection{\'Etude des états globaux}
\hypertarget{partie4.4}{
L'autre solution que je voyais pour résoudre le problème qu'ont rencontré mon maître de stage et ses collègues était de déclarer des prédicats \emph{\textcolor{blue}{global\_state(Gs)}} représentant les états globaux du réseau. 
Cela permet de déclarer dans des fichiers pour les sémantiques quelles sont les transitions locales jouables en utilisant un prédicat \emph{\textcolor{blue}{playable(Gs1, Gs2)}} signifiant que l'on peut aller depuis 
$Gs_1$ en $Gs_2$.}\\ \\
Le principal défaut de cette manière de procéder est que cela crée de nombreux atomes et demande à ASP de les garder en mémoire pendant toute sa résolution. De plus, déterminer si pour toute paire d'états globaux il existe une 
transition se fait en $O(k^2)$, avec $k=\displaystyle{\prod_{a\in\Sigma}C_a}$, alors que si l'on calcule les transitions jouables à chaque étape, on ne surcharge pas la mémoire du solveur. C'est à priori ce qui rend mon programme 
obsolète en terme de complexité.\\ \\
Les explications d'ASP que j'ai faites pour la \hyperlink{semantiques}{partie 3.2} sur les différentes sémantiques sont en réalité issues de mes propres fichiers pour ces trois sémantiques.\\ \\
Dans cette section, je compte expliquer comment fonctionne mon fichier ASP principal, ainsi que comment je m'y suis pris pour déclarer des états globaux sans modifier la manière d'écrire un automate (en ASP on ne peut pas créer 
de tuples ayant une arité variable en fonction d'un prédicat).\\ \\
J'ai d'abord défini deux fonctions en Python permettant de créer une constante pour un état global représenté par une liste-ASP (un objet que j'introduis par la suite) : ce sera la fonction \emph{\textcolor{blue}{work(g)}}, et de 
déterminer les niveaux des automates actifs de ces constantes : ce sera la fonction \emph{\textcolor{blue}{determine\_active\_level(a,g)}} . Je ne détaillerai pas le code de ces fonctions.\\
\begin{itemize}
	\item\emph{\textcolor{blue}{work(g)}} prend un état global encodé sous forme de liste-ASP et renvoie une constante unique en ASP représentant l'état global en entrée.\\
	\item\emph{\textcolor{blue}{determine\_active\_level(a,g)}} prend un automate a sous la forme d'une chaîne de caractères, et un état global g sous la forme de sa constante en ASP, et renvoie un prédicat "level(a, 	
	niveau\_de\_a)" en ASP.
\end{itemize}
La structure du code ASP reprend fortement celle de la \hyperlink{preexistante}{version pré-existante}, c'est pourquoi je ne vais pas la mettre intégralement.\\ \\
Après avoir introduit quelques informations (noms d'automates, transitions locales, étapes du chemin) comme c'est fait dans les 7 premières lignes de la version pré-existante, on introduit 2 prédicats supplémentaires utiles pour 
définir un ordre parmi les automates. On utilise alors une fonction de clingo : \#count \{E\} permettant de compter le nombre d'éléments dans l'ensemble E.\\ \\
\emph{
	8. \textcolor{blue}{nb\_automaton(N) :- N = \#count \{ A : automaton(A) \}.}\\
	9. \textcolor{blue}{nb\_level(A, N) :- automaton(A), N = \#count \{ L : automaton\_level(A, L) \}.}\\
	10. \textcolor{blue}{enum(1..N) :- nb\_automaton(N).}\\ \\
}
\`A l'aide des prédicats \emph{\textcolor{blue}{enum(k)}} que l'on vient juste de créer, on peut désormais définir un ordre pour les automates (il s'agit ici de l'ordre anti-lexicographique):\\ \\
\emph{
	11. \textcolor{blue}{1 \{ moment(A, N) : enum(N) \} 1 :- automaton(A).}\\
	12. \textcolor{blue}{1 \{ moment(A, N) : automaton(A) \} 1 :- enum(N).}\\
	13. \textcolor{blue}{:- }\\
	14.\qquad\textcolor{blue}{moment(A, N), moment(A2, N2),}\\
	15.\qquad\textcolor{blue}{automaton(A), automaton(A2),}\\
	16.\qquad\textcolor{blue}{enum(N), enum(N2),}\\
	17.\qquad\textcolor{blue}{N $<$ N2, A $<$ A2.}\\ \\
}
Une fois cet ordre défini, on est capable de créer une liste-ASP pour encoder chacun des états globaux. Pour N le nombre d'automates, et $1\leq k\leq N$, le $(N-k+1)^{ieme}$ élément de cette liste sera un prédicat \textcolor{blue}{\emph{nb(automaton, level)}} avec automaton étant 
$k^{ieme}$ au niveau de l'ordre défini précédemment (on empile dans la liste d'abord les premiers éléments, c'est pour ça qu'on a trié par ordre anti-lexicographique).\\ \\
\emph{
	18. \textcolor{blue}{build\_list(0, empty).}\\
	19. \textcolor{blue}{build\_list(N+1, (nb(A, 0..K-1), L)) :-}\\ 
	20.\qquad\textcolor{blue}{build\_list(N, L),}\\
	21.\qquad\textcolor{blue}{enum(N+1),}\\
	22.\qquad\textcolor{blue}{moment(A, N+1),}\\
	23.\qquad\textcolor{blue}{nb\_level(A, K).}\\ \\
}
On utilise ensuite nos fonctions Python pour travailler avec des constantes plus agréables à lire que des grosses listes ASP.\\ \\
\emph{
	24. \textcolor{blue}{gs(L) :- build\_list(N, L), nb\_automaton(N).}\\
	25. \textcolor{blue}{global\_state(@work(gs(L)), L) :- gs(L). }\\ 
	26. \textcolor{blue}{global\_state(Gs) :- global\_state(Gs, \_).}\\
	27. \textcolor{blue}{active\_in\_g(@determine\_active\_level(Automaton, L), Gs) :-}\\
	28.\qquad\textcolor{blue}{automaton(Automaton),}\\
	29.\qquad\textcolor{blue}{global\_state(Gs,L).}\\ \\
}
Avec tous ces éléments, il est alors très facile de poursuivre l'algorithme et de déclarer les 3 contraintes de l'attracteur comme on l'avait fait dans la version pré-existante : on choisit un état global à l'étape initiale 
(step 0), pour chaque étape on choisit un coup jouable en connaissant l'état dans lequel on se trouve à cette étape. Puis on détermine quel est l'état global de l'étape suivante, et on teste ensuite les trois contraintes avec les 
états globaux. La troisième contrainte est alors très simple à encoder maintenant que l'on a mémorisé les coups jouables dans la sémantique :\\ \\
\emph{
	30. \textcolor{blue}{also\_playable(Gs1, Gs2, Step) :-}\\
	31.\qquad\textcolor{blue}{playable(Gs1, Gs2),}\\
	32.\qquad\textcolor{blue}{not played(Gs1, Gs2, Step),}\\
	33.\qquad\textcolor{blue}{active\_g(Gs1, Step),}\\
	34.\qquad\textcolor{blue}{step(Step).}\\ \\
	35. \textcolor{blue}{evolves\_in\_main\_cycle(Gs1, Gs2, Step1, Step2) :-}\\
	36.\qquad\textcolor{blue}{playable(Gs1, Gs2),}\\
	37.\qquad\textcolor{blue}{active\_g(Gs1, Step1),}\\
	38.\qquad\textcolor{blue}{active\_g(Gs2, Step2).}\\ \\
	39. \textcolor{blue}{:- also\_playable(Gs1, Gs2, Step), not evolves\_in\_main\_cycle(Gs1, Gs2, Step, \_).}\\ \\
}
Les résultats de cette version sont décevants. Avec les mêmes tests que précédemment, je n'ai réussi à obtenir que 2 (sur 7) solutions en moins de 100s, ce qui n'est vraiment pas bon. Maxime Folschette et moi-même pensons que cela 
est dû à la trop grosse quantité de mémoire d'ASP gardée pour de trop nombreux prédicats.

\newpage
\section{Conclusion et pistes pour la suite}
Durant mon stage j'ai élaboré deux versions pour résoudre le problème rencontré avec l'ajout de la troisième contrainte. J'ai présenté dans ce rapport la solution qui fait appel à un script Python, ainsi que la version modifiée 
pour traiter la sémantique généralisée. J'ai très brièvement parlé de la solution nécessitant la création d'états globaux en ASP.\\ \\
Mes performances sur la batterie de test qu'a utilisé Maxime Folschette pour la version de laquelle je suis parti se sont avérées toutes aussi bonnes que celles de la sémantique asynchrone. Les résultats de ces tests sont 
disponibles sur le github de mon stage. Les performances de ma seconde version y sont également. On voit notamment à quel point 
elle n'est pas efficace en temps.\\ \\
Concernant cette seconde version, je pense que l'on peut grandement améliorer son efficacité en combinant mon code avec de l'incrémental. L'idée serait de ne considérer qu'un certain nombre d'états globaux : au début on les 
considère tous, puis, lorsque l'on trouve un attracteur, on regroundre le programme en enlevant tous les états globaux de l'attracteur (en les mettant tous à faux).\\ \\
Une autre idée que j'avais en tête était, lorsque l'on trouvait un cycle qui n'était pas un attracteur, de remplacer tous les états de ce cycle par un seul représentant, dont les transitions globales entrantes et sortantes 
seront celles de chacun des états globaux du cycle. On travaillerait ensuite avec des représentants et des états globaux comme s'il s'agissait du même objet (si on a un représentant dans un autre cycle, on l'agrandira en rajoutant 
les autres éléments du cycle). Je pense que combiner cette idée avec de l'incrémental pourrait également être intéressant : à chaque cycle trouvé on effectue de nouveau un grounding en mettant à jour nos représentants.\\ \\
Je ne suis pas sûr de ces pistes, mais c'est ce sur quoi j'essaierais personnellement de me pencher pour poursuivre le travail.\\ \\ \\
Enfin, je souhaite remercier l'ENS de Lyon qui m'a proposé ce stage, Maxime Folschette pour son encadrement, les personnes au sein de l'équipe BioComputing, mes quelques collègues stagiaires de bureau ainsi que mes quelques 
relecteurs anonymes.\\ \\
Mon code est disponible ici : \href{https://github.com/Leopoulpinator/Attractors-in-AAN}{https://github.com/Leopoulpinator/Attractors-in-AAN}.

\newpage
\bibliography{biblio}

\newpage
\section{Annexes}
\subsection{Contexte institutionnel et social du stage}
Mon stage a eu lieu dans le laboratoire CRIStAL (Villeneuve-d'Ascq, 59655) situé dans la cité scientifique de Lille. Ce laboratoire est rattaché à l’Université de Lille, à Centrale Lille et au CNRS.\\ \\
J'ai travaillé au sein de l'équipe BioComputing de ce laboratoire. Le maître de mon stage s'appelle Maxime Folschette et est membre de cette équipe. Cédric Lhoussaine (permanent au sein de l'équipe, et dirigeant de celle-ci) et 
Danilo Dursoniah (en troisième année de thèse) ont été les personnes avec lesquelles j'ai le plus discuté au sein de cette équipe.\\ \\
J'ai travaillé dans un bureau avec d'autres stagiaires, Danilo et un ingénieur (que je n'ai vu qu'une seule fois). J'ai eu plusieurs échanges avec 2 autres stagiaires qui étaient mes collègues de bureau. Nous avons pu discuter de 
nos parcours respectifs ainsi que de nos sujets de stage, de nos manières de réfléchir sur les problèmes qui nous ont été posés. Cependant, peu de monde était présent en présentiel chaque jour donc les échanges que j'ai eu avec mes 
collègues de bureau ont été assez faibles. Même s'ils n'ont pas été très nombreux, j'ai beaucoup apprécié ces moments.\\ \\
Le métier de la recherche ne m'intéressait pas, mais j'ai découvert grâce à ce stage que cela me plaît en fait beaucoup. Quand j'essayais de résoudre des jeux comme le sokoban, le sudoku ou autres, j'avais l'impression d'être 
retourné en CPGE et de chercher à résoudre un exercice difficile d'un DM, ce qui était sans doute mon occupation favorite à l'époque.\\ \\ \\

\subsection{Organisation du GitHub}
Voici l'organisation de mon GitHub (\href{https://github.com/Leopoulpinator/Attractors-in-AAN}{https://github.com/Leopoulpinator/Attractors-in-AAN}) :\\
\begin{itemize}
	\item Le dossier first\_exercices\_in\_asp contient toutes mes versions du sokoban, ainsi que tous les autres jeux de logique que j'ai résolu en ASP (dans le dossier exemples\_perso/jeux\_logiques).
	\item Le dossier models contient tous les AAN encodés en ASP que j'ai utilisé pour faire des tests.
	\item Le dossier rapport contient toutes les données concernant le présent document.
	\item Le dossier resources contient des ressources en tout genre. La plus utile est le code de filtrage en ASP des attracteurs.
	\item Enfin, le dossier versions contient les versions finales dont j'ai parlé dans le présent document. Les deux dossiers solution\_only\_for\_... contiennent les codes sources des versions présentées partie 4.2 et 4.3 
	alors que le dossier final\_version\_with\_... contient toutes les versions de sémantique que j'ai pu expérimenter et tester. J'explique dans la partie 4.4 comment fonctionne le code source du fichier attractors.lp. 
	Chacun de ces dossiers possèdent un dossier de benchmarks regroupant tous les tests sur les modèles du dossier models. On a notamment des tableaux regroupant le temps d'exécution (\textless=100s) et d'autres présentant le 
	nombre d'attracteurs trouvés pour chaque modèle.
\end{itemize}

\end{document}





























