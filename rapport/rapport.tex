\documentclass[12pt,a4paper]{article}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage[a4paper,hmargin=19mm,vmargin=25mm]{geometry}
\usepackage{nameref}
\usepackage[symbol]{footmisc}
\usepackage{minitoc}
\usepackage{color}
\usepackage{amsmath}
\usepackage[francais]{babel}
\usepackage{natbib}
\setcounter{tocdepth}{3}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\renewcommand{\contentsname}{Table des matières}

\bibliographystyle{dinat}

\input{macros/macros}
\input{macros/macros-ph}
\input{macros/tikzstyles2.tex}

\begin{document}

\begin{titlepage}
    \begin{center}
        \textsc{\Large Rapport de stage de L3}\\

    \vspace{2.5cm}

        \HRule\\
        {\huge\scshape Analyse de la dynamique des modèles biologiques par programmation logique\par}
        \HRule\\

    \vspace{3cm}

        \large
        Léo-Paul \textsc{Delsaux}\footnote[2]{ENS de Lyon}\\

    \vspace{1cm}

        \large
        \emph{Encadrant du stage} \\
        Maxime \textsc{Folschette}\footnote[3]{Équipe Bio-Computing, labortaoire CRIStAL, CNRS de Lille}\\

    \vfill

        {\large Juin-Août 2022}
    \end{center}
\end{titlepage}

\addtocontents{toc}{\protect\hypertarget{toc}{}}

\fancypagestyle{plain}{%
\fancyhf{}
\cfoot{\hyperlink{toc}{\thepage}}%
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}}
\pagestyle{plain}%

\newpage
\tableofcontents

\newpage
\section{Introduction}
Ce rapport fait écho au chapitre [\cite{chapitre}]. Mon stage a démarré par la lecture complète de ce chapitre, nécessaire pour traiter le sujet.
Mon rapport démarrera donc par introduire les notions majeurs de ce chapitre.\\ \\
La biologie s'intéresse à l'étude des systèmes vivants ou composant le vivant (gènes, cellules, écosystèmes...). La bioinformatique est l'utilisation de méthodes informatiques pour aider la biologie. Un des domaines de la 
bioinformatique s'apelle la \emph{biologie des systèmes} et consiste à proposer des modèles et des méthodes informatiques et mathématiques pour représenter et étudier de tels systèmes.\\ \\
Ainsi, des études biologiques permettent de déterminer comment certains gènes interagissent entre eux, ce qui peut être représenté mathématiquement sous la forme d'un graphe. De plus, ces interactions peuvent être vues comme des 
transitions entre les sommets de notre graphe, ce qui se rapproche alors plus d'un automate. La représentation du modèle étudié lors de ce stage est explicité dans le chapitre Modèle.\\ \\
L'étude de la dynamique de systèmes biologiques lève plusieurs problèmes tels que l'identification d'attracteurs, les bifurcations ou encore la connexité entre deux états globaux. Dans ce rapport je vais discuter de la recherche 
d'attracteurs dans des réseaux d'automates asynchrones : il s'agit d'un ensemble d'états duquel on ne peut pas s'échapper et minimal au sens de l'inclusion.\\ \\
Answer Set Programming (= ASP) est un paradigme de programmation logique particulièrement efficace pour résoudre des problèmes combinatoires. Je n'ai travaillé qu'avec ce langage (et un peu de scripting python) 
durant mon stage afin de chercher les attracteurs parmi le graphe des états globaux de notre réseau.\\ \\
Ce qui sera étudié dans ce rapport ne le sera que partiellement : on n'entrera pas en détail dans le code présenté, mais on se penchera simplement sur les grandes lignes et sur les points techniques qu'il arbore.

\section{Answer Set Programming}
L'Answer Set Programming (ASP) est un paradigme de programmation logique comparable à Prolog. Ces dernières décennies, ASP s'est trouvé être puissant pour traiter des modèles biologiques, permettant de parcourir un 
grand nombre de configurations rapidement. ASP peut énumérer facilement les ensembles solutions à un problème qu'on lui encode : c'est un paradigme très efficace pour la combinatoire. Nous allons ici présenter brièvement 
son fonctionnement, et plus précisément, les outils qui ont été utiles pour mon stage.
\subsection{Termes}
ASP fonctionne à l'aide de déclarations de faits, de règles, de prédicats contenant un ou plusieurs arguments tels que : \emph{\textcolor{blue}{parentOf(jenny, charles)}}, ce qui nécessite tout d'abord que j'introduise la notion 
de \textbf{terme} (ou \textbf{atome}). On définit un terme de la manière suivante : 
\begin{enumerate}
	\item terme simple :
		\begin{itemize}
		\item un entier relatif (0, -35, 42)
		\item une constante qui démarre par une lettre minuscule(v0us, lis35, quatre, ex3mpl35)
		\item une chaîne de caractères encadrée de guillemets ("ma\_chaine\_de\_caracteres", "42")
		\item une variable identique grammaticalement aux constantes, mais dont la première lettre est majuscule (N0u5, S0mm35, D35, V4r14bl35)
		\item un (ou plusieurs) underscore symbolisant une variable sans nom (\_, \_\_)
		\end{itemize}
	\item une fonction (qu'on appellera également prédicat) est de la forme : constante($t_1$, $t_2$, ..., $t_k$) avec un nombre de termes (qui sont les arguments) fini qui peut être nul (f(23), je\_suis\_une\_fonction(42, 
	true), et\_moi\_aussi(oui)).\\
	Ces fonctions n'ont pas vocation à calculer, mais uniquement à déclarer des objets avec les arguments souhaités comme étant vrais.
	\item un tuple de la forme : ($t_1$, $t_2$, ..., $t_k$) avec un nombre de termes fini qui ne peut être nul ((37, oui), (), (1, h(-4), 0, 1)).
\end{enumerate}
\subsection{Règles et modèles d'un programme}
Un \emph{programme d'ensemble solutions ( = answer set program)} est un nombre fini de règles de la forme :

\begin{center}
$a_0$ :- $a_1,...,a_m,not \: a_{m+1},...,not \: a_n.$
\end{center}
avec $n\geq m\geq m\geq 0$. $a_0$ est un atome ou $\bot$ (Bottom/le Faux) et représente ici la \textbf{tête} de la règle. Les $a_1,...,a_n$ sont des atomes et représente quant à eux le \textbf{corps} de la règle, et le symbole $"not"$ 
représente la négation par l'échec. Cette règle se lit intuitivement : si les atomes $a_1,..,a_m$ sont tous vrais et qu'aucun des atomes $a_{m+1},...,a_n$ n'est vrai, alors $a_0$ est vrai.\\ \\
Si $n=m=0$, cela signifie que $a_0$ est vrai. Dans ce cas, on parle d'un fait, et on ne doit pas renseigner ":-". D'une autre part, si $a_0=\bot$, on parle de contrainte : comme $\bot$ ne peut jamais être vrai, si le corps de la 
règle est vrai, cela 
invalide la solution actuelle. On ne renseigne pas $\bot$ pour la tête, on laisse une tête vide au niveau du code.\\ \\
Cette notion de "solution actuelle" se formalise de la façon suivante : on parle d'une \textbf{interprétation} $I$ en tant qu'ensemble fini d'atomes propositionnels. Une règle $r$ définie comme ci-dessus est \emph{vraie dans I} si 
et seulement si :

\begin{center}
$\left\{a_1,...,a_m\right\}\subseteq I \wedge \left\{a_{m+1},...,a_n\right\} \cap I = \emptyset \Rightarrow a_0 \in I$
\end{center}

Si toutes les règles d'un programme $P$ sont vraies dans une même interprétation $I$ et que $I$ est maximale, alors on dit que $I$ est un \textbf{modèle} de $P$. Lorsque l'on déclare un problème $P$ en ASP, le solveur nous renverra en sortie tout 
les modèles possibles pour $P$.
\subsection{Variables}
Si une variable apparaît dans un atome de la tête, elle doit également être dans le corps. Chaque instance d'une variable va être groundée par clingo afin de trouver tous les modèles à notre problème.
Prenons un petit exemple, voici un problème encodé avec 2 règles :
\begin{center}
\emph{
	\textcolor{blue}{
  parentOf(jenny, charles).\\
  parentOf(mary, jenny).
	}
}
\end{center}
Ce programme contient 2 faits : Charles est un parent de Jenny, et Jenny est un parent de Mary. C'est ainsi que l'on souhaite comprendre les termes "parentOf(jenny, charles)" et "parentOf(mary, jenny)".
Si on souhaite désormais spécifier que Charles est un grand parent de Mary, on peut le faire en ajoutant le terme : "grandparentOf(mary, charles)". Cependant, ASP est capable de faire de la déduction.
En effet, on peut généraliser la notion de grand parent comme étant le parent d'un parent de la façon suivante :
\begin{center}
\emph{
	\textcolor{blue}{
  grandparentOf(X, Z) :- parentOf(X, Y), parentOf(Y, Z).
	}
}
\end{center}
Pour chaque valeurs possible de X, Y, et Z, le grounding d'ASP va nous créer des règles associées.
Ainsi, les 27 règles dont grandparentOf(mary, mary) :- parentOf(mary, mary), parentOf(mary, mary), ou encore grandparentOf(charles, mary) :- parentOf(charles, jenny), parentOf(jenny, mary) vont être créées 
par cette façon de procéder. Ceci n'est pas du tout un problème : le solveur d'ASP va simplement regarder si les atomes des queues sont vraies ou pas. Si ce n'est pas le cas, comme le faux implique tout, 
les règles seront vraies. Si c'est le cas, la tête sera alors mise à vraie. Sachant qu'une seule de ces 27 possibilités mène à la véracité d'un nouvel atome, on obtiendra en sortie d'ASP les faits suivants :
\begin{center}
\textcolor{blue}{
  SATISFAIBLE\\
	\emph{
  parentOf(jenny, charles)\\
  parentOf(mary, jenny)\\
  grandparentOf(mary, charles)
	}
}
\end{center}
\subsection{Agrégats}
Les agrégats forment le dernier outil d'ASP que j'ai utilisé dans le cadre de mon stage. Il s'agit d'un moyen de sélectionner un certain nombre d'atomes parmi un ensemble, et de les mettre à vrai. Ils se 
structurent suivant l'exemple suivant :
\begin{center}
\textcolor{blue}{
  0 $\left\{ coloration(X, Y, Teinte):couleur(Teinte)\right\}$ 1 :- abscisse(X), ordonnee(Y).
}
\end{center}
La \textbf{borne inférieure}, située à gauche des accolades (ici 0), et la \textbf{borne supérieure} (ici 1) définissent l'intervalle discret du nombre d'atomes que le solveur peut mettre à vrai. Si l'une de ces deux bornes est 
omise, ASP comprend qu'il s'agit de la borne maximale (ou minimale) possible (à savoir 0 pour la borne inf et cardinal de l'ensemble défini par les accolades pour la borne sup). Dans ce petit exemple, on choisira donc une ou 0 
couleur parmi celles possibles (telles qu'il existe un atome couleur(Teinte) avec la Teinte souhaitée qui soit vrai) pour chaque abscisse et ordonnée définies.\\
Les agrégats permettent de faire des disjonctions de cas.

\subsection{Premier exemple : le sudoku}
Durant les premières semaines de mon stage, j'ai encodé différents jeux de logique en ASP afin de me familiariser avec le langage. Le jeu le plus simple et connu que j'ai encodé a été le sudoku. Dans cette section, je vais 
briévement détailler le fonctionnement de ce code.\\
On codera une grille de sudoku en ASP en utilisant s, une fonction d'arité 3 prenant R, C et V comme argument, où R est la ligne, C la colonne et V la valeur de la case (R,C) dans la grille.
\begin{center}
\textcolor{blue}{
	$val(1..9)$.\\
}
\emph{1..9 est un raccourci pour dire itérer pour les entiers allant de 1 à 9. Ici, on déclare qu'il y a 9 valeurs dans une fonction d'arité 1 : 'val'}\\
\textcolor{blue}{
	$border(1;4;7)$.\\
}
\emph{On déclare également 3 autres faits pour mémoriser où sont situés les bordures de notre grille care le point virgule permet de  déclarer plusieurs atomes en un}\\
\textcolor{blue}{
	$1\left\{ s(R,C,V): val(V) \right\}1$ :- $val(R) ; val(C)$.\\
}
\emph{On ne prend qu'une seule valeur par carré}\\
\textcolor{blue}{
	$1\left\{ s(R,C,V): val(R) \right\}1$ :- $val(C) ; val(V)$.\\
}
\emph{Une valeur ne peut pas apparaître plusieurs fois dans la même colonne}\\
\textcolor{blue}{
	$1\left\{ s(R,C,V): val(C) \right\}1$ :- $val(R) ; val(V)$.\\
}
\emph{Ni dans la même ligne}\\
\textcolor{blue}{
	$1\left\{ s(R,C,V): val(R), val(C), R1<=R, R<=(R1+2), C1<=C, C<=(C1+2)\right\}1$ :- $val(V) ; border(R1) ; border(C1)$.\\
}
\emph{Une valeur ne peut pas apparaître plusieurs fois dans une sous-grille.}\\
\end{center}
Une fois que l'on a fait cela, il ne nous reste plus qu'à instancier notre problème sur une grille. Pour cela, on renseigne s(R,C,V) pour chaque case déjà pré-numérotée de la grille à notre code, et le solveur se chargera 
de nous renvoyer l'intégralité de la grille complétée.

\subsection{Scripting Python}
En ASP, on peut écrire des morceaux de script en Lua ou en Python. Pour cela, il suffit d'ajouter la commande '\#script (mon\_langage)', puis de taper son code dans le langage que l'on a choisi, et de finir le script par la 
commande '\#end.'. Le sccripting admet trois atouts majeurs :
\begin{itemize}
	\item L'appel au fonction en ASP via la commande '@ma\_fonction(et, ses, arguments)', permettant d'effectuer des calculs sous Python et de mettre des variables à vrai en fonction de ce qui a été trouvé dans ces 
	calculs.
	\item Un contrôle de la résolution permettant le filtrage des ensembles solutions, l'ajout de faits/règles, la demande de grounding et de solving. C'est ce dont je me suis le plus servi durant mon stage.
	\item Une méthode incrémentale efficace lorsque l'on a besoin d'avoir une notion de temporalité ou bien un calcul qui se fait dans un certain ordre : en fonction des résultats trouvés on peut partir sur une autre piste. La 
	notion d'ordre étant totalement inexistante en ASP (les lignes de code peuvent être écrites dans n'importe quel ordre), cela est pratique.
\end{itemize}

\subsection{Second exemple : le sokoban}
Le sokoban a été le dernier jeu de logique que j'ai encodé en ASP, et le plus complexe à cause de la duplication très couteuse du nombre de coups nécessaires pour la résolution d'une grille.\\ \\
Le jeu est composé d'une grille possédant des cases qui sont du sol ou du mur. Sur une case représentant le sol, il ya le joueur. Sur plusieurs autres cases de sol il y a des caisses. Sur autant de cases de sol qu'il y a de caisses, 
on trouve des cases d'arrivée (qui sont également du sol). Le but du jeu est de pousser toutes les caisses sur les cases d'arrivée sachant que le joueur ne peut se déplacer qu'en haut, à gauche, en bas ou à droite, et ne peut pas 
traverser les murs ni pousser une caisse s'il y a un mur ou une autre caisse derrière celle-ci.\\ \\
Une grille de sokoban est encodée en spécifiant quelles cases sont des murs, et quelles cases sont des sols avec les prédicats $mur(X,Y)$ et $sol(X,Y)$. On rensigne de plus un prédicat $init(X,Y)$, ce qui nous donne la position 
initiale du joueur, et $caisse\_init(Numero\_caisse,X,Y)$ nous renseignant sur les positions initiales des caisses (le premier argument varie de $1$ à $n$ lorsque l'on a $n$ de ces caisses). Enfin, le prédicat $arrivee(X,Y)$ 
symbolisera une case d'arrivée en $X,Y$.\\ \\
J'ai fait différentes versions pour ce jeu. L'une d'entre elles utilise une méthode incrémentale. Pour l'importer, il nous suffit d'ajouter la commande '\#include \textless incmode\textgreater .'. On doit alors définir les 
sous-programmes \emph{base}, \emph{step(k)} et \emph{check(k)}.\\
\begin{itemize}
	\item \textbf{base :}\\
	\emph{
		1. \textcolor{blue}{perso(0, R, C) :- init(R, C).}\\
		\% prédicats pour mémoriser la position du joueur à l'étape $0$\\
		2. \textcolor{blue}{caisse\_a\_instant(0, R, C) :- caisse\_init(\_, R, C).} \% ainsi que celles des caisses\\
	}
	\item \textbf{step(k) :}\\
	\emph{Pour des raisons de lisibilité, je ne mettrai qu'une instruction pour une seule direction}\\ \\
	\emph{
		3. \textcolor{blue}{acces\_a\_instant(k-1, R, C) :- perso(k-1, R, C).}\\
		\% prédicats pour mémoriser toutes les cases accessibles\\ \\
		4. \textcolor{blue}{acces\_a\_instant(k-1, R+1, C) :- sol(R+1, C), acces\_a\_instant(k-1, R, C), not caisse\_a\_instant(k-1, R+1, C).}\\
		\% on ajoute les cases à droite de celles accessibles (idem pour les 3 autres directions)\\ \\
		5. \textcolor{blue}{1 \{ coup\_a\_instant(k, (R, C), (R+1, C)) :} \% on peut faire un coup à l'instant $k$\\
		6.\qquad\qquad\textcolor{blue}{sol(R, C), sol(R+2, C),}\% si l'on a deux cases de sol $c_1$ et $c_2$\\
		7.\qquad\qquad\textcolor{blue}{acces\_a\_instant(k-1, R, C),}\% tels que l'on ait accès à $c_1$\\
		8.\qquad\qquad\textcolor{blue}{caisse\_a\_instant(k-1, R+1, C),}\% qu'il y ait une caisse entre $c_1$ et $c_2$\\
		9.\qquad\qquad\textcolor{blue}{not caisse\_a\_instant(k-1, R+2, C);}\% et qu'il n'y a pas de caisse en $c_2$\\
		10.\qquad\qquad\textcolor{blue}{[...]} \% idem pour les 3 autres directions\\
		11.\qquad\qquad \textcolor{blue}{\} 1}.\\ \\
		12. \textcolor{blue}{perso(k, R2, C2) :- coup\_a\_instant(k, \_, (R2, C2)).} \% Déplacement du personnage\\ \\
		13. \textcolor{blue}{caisse\_a\_instant(k, 2*R2-R, 2*C2-C) :-} \% On pousse une seule caisse : elle bouge\\
		14.\qquad\qquad \textcolor{blue}{sol(R2, C2), sol(R, C), sol(2*R2-R, 2*C2-C),}\\
		15.\qquad\qquad \textcolor{blue}{caisse\_a\_instant(k-1, R2, C2), coup\_a\_instant(k, (R, C), (R2, C2)).}\\ \\
		16. \textcolor{blue}{caisse\_a\_instant(k, R, C) :-} \% On ne pousse pas une caisse : elle ne bouge pas\\
		17.\qquad\qquad \textcolor{blue}{sol(R, C), sol(R2, C2),}\\
		18.\qquad\qquad \textcolor{blue}{caisse\_a\_instant(k-1, R, C), perso(k, R2, C2), R2 != R.}\\ \\
		19. \textcolor{blue}{caisse\_a\_instant(k, R, C) :-} \% Idem, mais pour les colonnes\\
		20.\qquad\qquad \textcolor{blue}{sol(R, C), sol(R2, C2),}\\
		21.\qquad\qquad \textcolor{blue}{caisse\_a\_instant(k-1, R, C), perso(k, R2, C2), C2 != C.}\\ \\
		22. \textcolor{blue}{caisse\_pas\_place(k) :- caisse\_a\_instant(k, R, C), not arrivee(R, C).}\\
		\% On détermine s'il existe encore des caisses qui ne sont pas placées pour l'étape $k$\\ \\
		23. \textcolor{blue}{fini(k) :- not caisse\_pas\_place(k).}\\
		\% Si toutes les caisses sont placées, on a fini la grille\\
	}
	\item \textbf{check(k) :}\\
	\emph{
		24. \textcolor{blue}{instant(k) :- k != 0.} \% si on est à un instant $k\geq1$\\
		25. \textcolor{blue}{:- not fini(k), query(k).} \% que l'on a fini à cette étape\\
		26. \textcolor{blue}{:- query(k), k = 0. \% et qu'on n'a pas $k=0$}\\ \\
		\% Alors check(k) est vrai, ce qui a pour conséquence d'arrêter les appels successifs à clingo (le grounder et solveur d'ASP), ce qui fait arrêter le programme
	}
\end{itemize}
On récupère alors la liste des coups de caisses à faire, et on peut résoudre notre grille en comblant les coups qui déplaçaient les caisses par ceux nécessaires pour atteindre la prochaine caisse à déplacer.

\section{Formalismes d'automates et leur dynamique}
Différents modèles existent pour représenter efficacement un système biologique et manipuler sa dynamique : les deux principaux sont les réseaux booléens synchrones de Stuart Kauffman, et les réseaux asynchrones de René Thomas.
Dans le cadre de mon stage je ne parlerai que des réseaux asynchrones, et plus particulièrement des réseaux d'automates asynchrone (AAN) [\cite{folschette2015sufficient}] et [\cite{pauleve2016pint}], qui forment une extension d'une précédente 
structure appelé "Process Hitting" [\cite{pauleve14}].\\

\subsection{AAN et leur traduction en ASP}
Un automate $A$, dans le contexte de mon stage, sera défini comme étant un ensemble d'états $q_0, q_1, ..., q_{|A|-1}$ avec des transitions dont les étiquettes seront un ou plusieurs états (qu'on appellera également \emph{niveaux}) 
d'automates externes. Il n'y a donc ni état final, ni état initial. On ne lui donnera pas non plus de mot à lire en entrée puisqu'on va s'intéresser à la dynamique de nos ensembles d'automates. On parlera alors de 
transition locale : $q_i\xrightarrow{l}q_j$ symbolisera le fait que l'on peut passer de l'état $q_i$ à l'état $q_j$ si toutes les conditions de $l$ sont vérifiés.\\
Un réseau d'automates asynchrone est un triplet $(\Sigma,S,T)$ avec :
\begin{itemize}
	\item $\Sigma=\left\{a,b,...\right\}$ est un ensemble fini d'automates non vides.
	\item Si $C_a$ est le nombre d'états d'un automate $a$, alors $S_a=\left\{a_0,a_1,...,a_{C_a-1}\right\}$ est l'ensemble des \textbf{états locaux} de l'automate $a$. $S=\displaystyle{\prod_{a\in\Sigma}}S_a$ est l'ensemble 
	fini des \textbf{états globaux}, et $LS=\displaystyle{\bigcup_{a\in\Sigma}}S_a$ représente l'ensemble de tous les états locaux.
	\item Pour chaque $a\in\Sigma$, $T_a\subseteq\left\{a_i\xrightarrow{l}a_j\in S_a\times\rho(LS/S_a)\times S_a|a_i\neq a_j\right\}$ est l'ensemble des \textbf{transitions locales} d'un automate $a$, avec 
	$\rho$ qui désigne la puissance ensembliste. $T=\displaystyle{\bigcup_{a\in\Sigma}}T_a$ est l'ensemble des transitions locales du modèle.\\ \\
\end{itemize}
\textbf{Exemple :} On représente l'AAN suivant de cette manière :
\begin{itemize}
	\item $\Sigma =\left\{a,b,c\right\}$
	\item $S_a=\left\{a_0,a_1,a_2\right\}$, $S_b=\left\{b_0,b_1\right\}$ et $S_c=\left\{c_0,c_1,c_2\right\}$
	\item $T_a = \left\{a_0\xrightarrow{b_0}a_1,a_0\xrightarrow{b_1,c_1}a_1,a_1\xrightarrow{b_1}a_0,a_1\xrightarrow{b_0}a_2,a_2\xrightarrow{b_1}a_1\right\}$\\
	$T_b=\left\{b_0\xrightarrow{c_0}b_1,b_1\xrightarrow{a_2}b_0\right\}$\\
	$T_c=\left\{c_0\xrightarrow{b_1}c_1,c_0\xrightarrow{a_2}c_2,c_1\xrightarrow{b_0}c_0,c_1\xrightarrow{a_1}c_2,c_2\xrightarrow{b_1}c_0\right\}$
\end{itemize}
\begin{center}
\begin{tikzpicture}[apdotsimple/.style={apdot}]

  \TSort{(0,2)}{a}{3}{r}
  \TSort{(2.5,0)}{b}{2}{r}
  \TSort{(5,2)}{c}{3}{r}

  \path[local transitions]
    (a_0) edge node[auto] {$b_0$} (a_1)
    (a_1) edge node[auto] {$b_0$} (a_2)
    (a_2) edge node[auto] {$b_1$} (a_1)
    (a_1) edge node[auto] {$b_1$} (a_0)

    (b_0) edge node[auto] {$c_0$} (b_1)
    (b_1) edge node[auto] {$a_2$} (b_0)

    (c_0) edge node[auto] {$b_1$} (c_1)
    (c_1) edge node[auto] {$b_0$} (c_0)
    (c_1) edge node[auto] {$a_1$} (c_2)
    ;
  \path[local transitions, bend left = 105]
      (a_0) edge node[auto] {$b_1, c_1$} (a_1)
    ;
  \path[local transitions, bend left = 90]
      (c_0) edge node[auto] {$a_2$} (c_2)
    ;
  \path[local transitions, bend left = 90]
      (c_2) edge node[auto] {$b_1$} (c_0)
    ;

  \TState{a_0, b_1, c_1}
\end{tikzpicture}
\end{center}
En ASP, on définira un AAN en deux temps :
\begin{itemize}
	\item On commencera par déclarer chacun de nos automates avec les niveaux (= états) qu'il contient :
	\begin {center}
	\emph{
		\textcolor{blue}{
		automaton\_level("a", 0..2).\\
		automaton\_level("b", 0..1).\\
		automaton\_level("c", 0..2).\\
		}
	}
	\end{center}
	\item Enfin, les transitions seront encodés via des labels (t1, t2, ...), et on donnera chacune des conditions, ainsi que l'état d'arrivée, via un fait :
	\begin {center}
	\emph{
		\textcolor{blue}{
		condition(t1, "a", 0). target(t1, "a", 1). condition(t1, "b", 0).\\
		condition(t2, "a", 1). target(t2, "a", 2). condition(t2, "b", 0).\\
		condition(t3, "a", 2). target(t3, "a", 1). condition(t3, "b", 1).\\
		condition(t4, "a", 1). target(t4, "a", 0). condition(t4, "b", 1).\\
		condition(t5, "b", 0). target(t5, "b", 1). condition(t5, "c", 0).\\
		condition(t6, "b", 1). target(t6, "b", 0). condition(t6, "a", 2).\\
		condition(t7, "c", 0). target(t7, "c", 1). condition(t7, "b", 1).\\
		condition(t8, "c", 1). target(t8, "c", 0). condition(t8, "b", 0).\\
		condition(t9, "c", 1). target(t9, "c", 2). condition(t9, "a", 1).\\
		condition(t10, "c", 0). target(t10, "c", 2). condition(t10, "a", 2).\\
		condition(t11, "c", 2). target(t11, "c", 0). condition(t11, "b", 1).\\
		condition(t12, "a", 0). target(t12, "a", 1). condition(t12, "b", 1). condition(t12, "c", 1).\\
		}
	}
	\end{center}
\end{itemize}
Nous avons ainsi défini l'automate de notre \textbf{exemple} en ASP.

\subsection{Sémantiques}
Soit $R = (\Sigma,S,T)$ un AAN (défini ci-dessus). On définit la notion de transition jouable:
\begin{itemize}
	\item On dit qu'une transition locale est \textbf{jouable} si toutes les conditions de celle-ci sont vérifiés\\
	On notera $P_{\zeta}$ l'ensemble des transitions locales jouables depuis un état global $\zeta$\\
	\emph{L'état global $(a_0,b_1,c_1)$ de l'\textbf{exemple} admet une seule transition jouable : $a_0\xrightarrow{b_1,c_1} a_1$}
\end{itemize}
La dynamique d'un AAN se définit à l'aide de sa \textbf{sémantique}. La sémantique forme l'ensemble des propriétés définissant les \textbf{transitions globales jouables} : dans un AAN on s'intéresse à l'évolution globale du réseau.
\subsubsection{Asynchrone}
Soit $R = (\Sigma,S,T)$ un AAN, et $\zeta\in S$ un état global. L'ensemble des transitions globales jouables depuis $\zeta$ pour la sémantique \emph{asynchrone} est donnée par :
\begin{center}
	$U^{asyn}(\zeta)=\left\{\left\{a_i\xrightarrow{l} a_j\right\}|a_i\xrightarrow{l} a_j\in P_{\zeta}\right\}$
\end{center}
De manière informelle : chaque transition locale jouable est une transition globale.\\ \\
En ASP, on commence donc par déclarer que deux états globaux sont différents sur un automate à l'aide de la règle suivante :\\
\emph{
1. \textcolor{blue}{different\_on(Gs1, Gs2, Automaton) :-} \% Cet atome est vrai\\
2.\qquad \textcolor{blue}{global\_state(Gs1), global\_state(Gs2), Gs1 != Gs2,} \% si deux états globaux diffèrent\\
3.\qquad \textcolor{blue}{automaton(Automaton),} \% qu'il existe un automate\\
4.\qquad \textcolor{blue}{active\_in\_g(level(Automaton, LevelI), Gs1),} \% sur lequel $Gs1$ vaut $I$\\
5.\qquad \textcolor{blue}{active\_in\_g(level(Automaton, LevelJ), Gs2),} \% et sur lequel $Gs2$ vaut $J$\\
6.\qquad \textcolor{blue}{LevelI != LevelJ.} \% avec $I \neq J$\\ \\
}
Ensuite, on fait comprendre à ASP qu'une transition locale n'est pas jouable si l'une (au moins) de ses conditions n'est pas vérifiée de la façon suivante :\\
\emph{
1. \textcolor{blue}{unplayable(Transition, Gs) :-} \% Cet atome est vrai\\
2.\qquad \textcolor{blue}{local\_transition(Transition),} \% s'il existe une transition locale\\
3.\qquad \textcolor{blue}{global\_state(Gs),} \% un état global\\
4.\qquad \textcolor{blue}{automaton(Automaton),} \% et un automate\\
5.\qquad \textcolor{blue}{active\_in\_g(level(Automaton, LevelI), Gs),} \% sur lequel $Gs$ vaut $I$\\
6.\qquad \textcolor{blue}{condition(Transition, Automaton, LevelJ),} \% alors qu'il devrait valoir $J\neq I$\\
7.\qquad \textcolor{blue}{LevelI != LevelJ.} \% pour que la transition soit jouable\\ \\
}
On déclare ensuite que deux états globaux différent sur au moins un autre automate qu'$Automaton$ avec le terme $not\_equal\_except(Automaton, Gs1, Gs2)$ comme ceci :\\
\emph{
1. \textcolor{blue}{not\_equal\_except(Automaton, Gs1, Gs2) :-} \% Cet atome est vrai\\
2.\qquad \textcolor{blue}{automaton(Automaton), automaton(Automaton2),} \% s'il existe deux automates\\
3.\qquad \textcolor{blue}{Automaton != Automaton2,} \% qui différent\\
4.\qquad \textcolor{blue}{global\_state(Gs1), global\_state(Gs2),} \% deux états globaux\\
5.\qquad \textcolor{blue}{different\_on(Gs1, Gs2, Automaton2).} \% tels que $Gs1 \neq Gs2$ sur Automaton2\\ \\
}
On peut enfin définir ce qu'est une transition globale jouable à l'aide de nos trois précédentes règles :\\
\emph{
1. \textcolor{blue}{playable(Gs1, Gs2) :-} \% Cet atome est vrai\\
2.\qquad \textcolor{blue}{global\_state(Gs1), global\_state(Gs2),} \% s'il existe deux états globaux $Gs1$ et $Gs2$\\
3.\qquad \textcolor{blue}{automaton(Automaton), local\_transition(Transition),} \% un automate et une transition\\
4.\qquad \textcolor{blue}{target(Transition, Automaton, LevelJ),} \% qui fait changer le niveau de l'automate\\
5.\qquad \textcolor{blue}{not unplayable(Transition, Gs1),} \% et avec la transition (locale) qui est jouable\\
6.\qquad \textcolor{blue}{not not\_equal\_except(Automaton, Gs1, Gs2),} \% et $Gs1=Gs2$ excepté sur Automaton\\
7.\qquad \textcolor{blue}{active\_in\_g(level(Automaton, LevelI), Gs1),} \% tel que le niveau d'$Automaton$ dans $Gs1$\\
8.\qquad \textcolor{blue}{active\_in\_g(level(Automaton, LevelJ), Gs2),} \% et celui dans $Gs2$\\
9.\qquad \textcolor{blue}{LevelI != LevelJ.} \% sont différents\\
}
\subsubsection{Synchrone}
Soit $R = (\Sigma,S,T)$ un AAN, et $\zeta\in S$ un état global. L'ensemble des transitions globales jouables depuis $\zeta$ pour la sémantique \emph{synchrone} est donnée par :
\begin{center}
	$U^{syn}(\zeta)=\left\{u\subseteq T|u \neq \emptyset \wedge \forall a\in\Sigma,(P_{\zeta}\bigcap T_a = \emptyset \Rightarrow u\bigcap 
	T_a=\emptyset)\wedge(P_{\zeta}\bigcap T_a\neq\emptyset\Rightarrow |u\bigcap T_a |=1\right\}$
\end{center}
De manière informelle : tous les automates possédant au moins une transition locale jouable doivent changer de niveau.\\ \\
Pour coder cela en ASP, on peut se servir des atomes \emph{\textcolor{blue}{different\_on}} et \emph{\textcolor{blue}{unplayable}}.\\
On ajoute de plus une autre règle : \emph{\textcolor{blue}{has\_playable(Automaton, Gs, LevelI, LevelJ)}} spécifiant que l'on peut faire changer $Automaton$ dans $Gs$ du niveau $I$ vers le niveau $J$.\\
Enfin, il ne nous reste plus qu'a déclarer (par la négation) quelles sont les transitions globales qui ne sont pas jouables. Pour cela, on essaie pour toutes les paires d'états globaux si on peut faire la transition de l'un à 
l'autre en créant un terme \emph{\textcolor{blue}{not\_playable(Gs1,Gs2)}} si la transition ne peut pas avoir lieu. On énumère alors les différents cas de figure :
\begin{enumerate}
	\item si $Automaton$ n'admet aucune transition locale jouable dans $Gs1$ et que $Gs1\neq Gs2$ sur $Automaton$
	\item si $Automaton$ admet une (ou plusieurs) transition locale jouable dans $Gs1$ et qu'il n'existe pas de transition pour faire passer le niveau d'$Automaton$ sur $Gs1$ à celui de $Gs2$
	\item si aucune transition locale n'est jouable depuis $Gs1$
\end{enumerate}
alors la transition $Gs1\rightarrow Gs2$ n'est pas jouable.\\
Enfin, il nous suffit de tester pour toutes les paires d'états globaux distincts si on a \emph{\textcolor{blue}{not\_playable(Gs1,Gs2)}} ou pas. Dans le cas contraire, alors on crée l'atome 
\emph{\textcolor{blue}{playable(Gs1,Gs2)}}.

\subsubsection{Généralisée}
Soit $R = (\Sigma,S,T)$ un AAN, et $\zeta\in S$ un état global. L'ensemble des transitions globales jouables depuis $\zeta$ pour la sémantique \emph{généralisée} est donnée par :
\begin{center}
	$U^{gen}(\zeta)=\left\{u\subseteq T|u \neq \emptyset \wedge \forall a\in\Sigma,(P_{\zeta}\bigcap T_a = \emptyset \Rightarrow u\bigcap 
	T_a=\emptyset)\wedge(P_{\zeta}\bigcap T_a\neq\emptyset\Rightarrow |u\bigcap T_a |\leq 1\right\}$
\end{center}
De manière informelle : tous les automates possédant au moins une transition locale jouable \underline{peuvent} changer de niveau, et au moins l'un d'entre eux doit changer de niveau.\\ \\
Pour coder cela en ASP, on prend exactement le code de la sémantique synchrone, en remplaçant le second cas de figure par ceci :\\ \\
2. si $Gs1$ différe de $Gs2$ sur $Automaton$ et qu'il n'existe pas de transition pour faire passer le niveau d'$Automaton$ sur $Gs1$ à celui de $Gs2$\\ \\
Cela permet bien de ne pas prendre une transition par automate qui est jouable puisqu'on va tester des paires d'états globaux qui ont peut-être 3 automates jouables, et si l'on ne fait qu'une seule transition locale cela ne sera pas 
filtré par notre atome \emph{\textcolor{blue}{not\_playable(Gs1,Gs2)}}.
\subsection{Dynamique}
Soit $U$ une sémantique. On introduit les dernières notions nécessaires pour la définition d'un attracteur :
\begin{itemize}
	\item On appelle \textbf{état stable} un état global ne possédant aucune transition globale jouable pour $U$.\\
	\emph{Dans l'\textbf{exemple}, aucun état global n'est stable pour la sémantique asynchrone (et donc cela est également vrai pour la sémantique synchrone et généralisée)}
	\item Pour $Gs_1,Gs_2\in S$, on notera $Gs_1\rightarrow _UGs_2$ pour symboliser le fait qu'il existe $u\in U(Gs_1)$ tel que si l'on joue toutes les transitions locales de $u$, alors $Gs_1$ devient $Gs_2$.
	\item Un \textbf{chemin} est une famille finie $(A_k)_{1\leq k\leq n}$ et ordonnée d'états globaux tels que pour tout $1\leq k\leq n-1$, $A_k\rightarrow _U A_{k+1}$.
	\item Un \textbf{cycle} est un chemin $(A_k)_{1\leq k\leq n}$ tel que $A_1=A_n$.
	\item Un \textbf{domaine de piège} est un ensemble non vide d'états globaux $S_E\in S$ tel que toute transition globale jouable depuis $S_E$ arrive dans un état global de $S_E$. Plus formellement : 
	$\forall\zeta _1\in S_E \wedge\forall\zeta _2\in S, \zeta _1 \rightarrow _U\zeta _2 \Rightarrow\zeta _2\in S_E$
\end{itemize}
Enfin, on peut définir ce qu'est un attracteur.\\
Un ensemble $A\subseteq S$ d'états globaux, avec $|A|\geq2$ est appellé \textbf{attracteur} si et seulement si c'est un domaine de piège minimal en terme d'inclusion ensembliste.\\
Un travail précédent ([\cite{chapitre}]) a démontré le résultat mathématique suivant dont on va se servir pour trouver les attracteurs au sein d'un AAN :\\ \\
\textbf{Lemme :} Les attracteurs d'un AAN sont exactement les domaines de piège cycliques.

\section{Contribution personnelle}
La version de laquelle j'ai commencé à travailler est assez proche du travail que j'ai effectué. Cette version était fonctionnelle et efficace pour la sémantique synchrone, mais ne fonctionnait pour la sémantique synchrone que 
lorsque les attracteurs étaient exactement des cycles simples (chaque état global du graphe produit doit avoir un degré sortant égal à $1$), et ne fonctionnait pas pour les autres AAN comme celui-ci :

\begin{center}
\begin{tikzpicture}[apdotsimple/.style={apdot}]

  \TSort{(0,2)}{a}{3}{r}
  \TSort{(3,2)}{b}{3}{r}

  \path[local transitions]
    (a_0) edge node[auto] {$b_0$} (a_1)
    (a_1) edge node[auto] {$b_1$} (a_2)
    (a_2) edge node[auto] {$b_1$} (a_1)

    (b_0) edge node[auto] {$a_0$} (b_1)
    (b_1) edge node[auto] {$a_1$} (b_2)
    (b_2) edge node[auto] {$a_1$} (b_1)
    ;
    
    \path[local transitions, bend left = 90]
      (a_0) edge node[auto] {$b_0$} (a_2)
    ;
    \path[local transitions, bend left = 90]
      (a_2) edge node[auto] {$b_2$} (a_0)
    ;
    \path[local transitions, bend left = 90]
      (b_0) edge node[auto] {$a_0$} (b_2)
    ;
    \path[local transitions, bend left = 90]
      (b_2) edge node[auto] {$a_2$} (b_0)
    ;
\end{tikzpicture}
\end{center}
En effet, l'ensemble $\left\{(0,0),(1,1),(1,2),(2,1),(2,2)\right\}$ est un attracteur de cet AAN pour la sémantique synchrone. De plus, il existe deux (même quatre ici) transitions globales jouables depuis l'état global $(0,0)$ : 
on peut aller en $(1,1)$ ou encore en $(2,2)$.\\ \\
Après avoir identifié le problème au sein du code, j'ai trouvé deux alternatives pour corriger cela : la première consiste à reprendre tout le code, enlever le problème ciblé et corriger cela avec un script Python, et la seconde 
consiste à considérer les états globaux et à définir les transitions globales jouables dans des fichiers dédiés aux sémantiques.\\
 Lors de mon exploration de la seconde alternative, je me suis confronté à de nombreux problèmes, et la complexité finale de mon algorithme étant piteuse, je ne parlerai dans ce rapport que de la première alternative.\\
Je vais donc détailler comment nous arrivons à trouver les attracteurs au sein des AAN en ASP avec la sémantique synchrone.

\subsection{Code pré-existant}
\emph{
	On commence par renseigner quelques faits utiles pour pouvoir manipuler aisèment les informations que l'on a à disposition.\\ \\
	\%\%\% Initialisation (faits étendus)\\
	\% Noms des automates\\
	1. \textcolor{blue}{automaton(Automaton) :- automaton\_level(Automaton, \_).}\\
	\% Noms des transitions locales\\
	2. \textcolor{blue}{local\_transition(Transition, Automaton) :- target(Transition, Automaton, \_).}\\
	3. \textcolor{blue}{local\_transition(Transition) :- target(Transition, \_, \_).}\\ \\
	\%\%\% Etapes\\
	\% Etapes dans tout le chemin\\
	4. \textcolor{blue}{step(0..n).} \% Ici n est une constante qu'on définit lors de la compilation (souvent 10)\\
	\% Longueur du cycle principal (i.e., un sous-chemin cyclique)\\
	5. \textcolor{blue}{1 \{main\_cycle\_length(N) : step(N), N \textgreater 0 \} 1.}\\
	\% Etapes dans le cycle principal\\
	6. \textcolor{blue}{cycle\_step(0..N) :- main\_cycle\_length(N).}\\
	\% Etapes après le cycle principal\\
	7. \textcolor{blue}{after\_cycle\_step(N+1..n) :- main\_cycle\_length(N).}\\ \\ \\
	On choisit ensuite un état initial, on définit les transitions non jouables, et la sémantique.\\ \\
	\%\%\% Etat initial\\
	\% On sélectionne aléatoirement un état inital (step "0")\\
	8. \textcolor{blue}{1 \{ active(level(Automaton, Level), 0) : automaton\_level(Automaton, Level) \} 1 :-}\\
	9.\qquad\qquad\textcolor{blue}{automaton(Automaton).}\\ \\
	\%\%\% Préparation pour le calcul des transitions jouables par la sémantique\\
	\% Calcule les transitions locales non jouables pour chaque étape\\
	10. \textcolor{blue}{unplayable(Transition, Step) :-}\\
	11.\qquad\qquad\textcolor{blue}{active(level(Automaton, LevelI), Step),}\\
	12.\qquad\qquad\textcolor{blue}{condition(Transition, Automaton, LevelJ),}\\
	13.\qquad\qquad\textcolor{blue}{LevelI != LevelJ, step(Step).}\\ \\
	\%\%\% Sémantique synchrone\\
	\% On renseigne les automates qui ont au moins une transition locale jouable\\
	14. \textcolor{blue}{has\_playable(Automaton, Step) :-}\\
	15.\qquad\qquad\textcolor{blue}{not unplayable(Transition, Step),}\\
	16.\qquad\qquad\textcolor{blue}{local\_transition(Transition, Automaton),}\\
	17.\qquad\qquad\textcolor{blue}{step(Step).}\\ \\
	\% On sélectionne une transition à jouer pour chaque automate si possible\\
	18. \textcolor{blue}{1 \{played(Transition, Step) :}\\
	19.\qquad\qquad\textcolor{blue}{not unplayable(Transition, Step),}\\
	20.\qquad\qquad\textcolor{blue}{local\_transition(Transition, Automaton)}\\
	21. \textcolor{blue}{\} 1 :- has\_playable(Automaton, Step).}\\ \\
	\% Contrainte : on doit jouer au moins une transition locale à chaque étape\\
	22. \textcolor{blue}{:- 0 \{ played(\_, Step) \} 0, step(Step).}\\ \\ \\
	Maintenant que l'on a choisi notre coup, on en déduit l'état suivant.\\ \\
	\%\%\% Calcule l'état suivant, le successeur de chaque S\\
	\% A Step, Automaton utilisent les Transition pour changer du niveau LevelI à LevelJ\\
	23. \textcolor{blue}{change(Transition, Automaton, LevelI, LevelJ, Step) :-}\\
	24.\qquad\qquad\textcolor{blue}{played(Transition, Step),}\\
	25.\qquad\qquad\textcolor{blue}{target(Transition, Automaton, LevelJ),}\\
	26.\qquad\qquad\textcolor{blue}{condition(Transition, Automaton, LevelI).}\\ \\
	\% On change le niveau actif s'il y a un changement dans Automaton\\
	27. \textcolor{blue}{active(level(Automaton, LevelK), Step + 1) :-}\\
	28.\qquad\qquad\textcolor{blue}{change(\_, Automaton, \_, LevelK, Step),}\\
	29.\qquad\qquad\textcolor{blue}{Step \textless n.}\\ \\
	\% On garde le niveau actif s'il n'y a pas de changement dans Automaton\\
	30. \textcolor{blue}{active(level(Automaton, LevelK), Step + 1) :-}\\
	31.\qquad\qquad\textcolor{blue}{not change(\_, Automaton, \_, \_, Step),}\\
	32.\qquad\qquad\textcolor{blue}{active(level(Automaton, LevelK), Step),}\\
	33.\qquad\qquad\textcolor{blue}{step(Step), Step \textless n.}\\ \\
}
Je viens ici d'expliquer comment faire pour générer tous les chemins de longueur n avec la sémantique synchrone. Cependant, pour qu'un de ses chemins nous intéressent, il faut qu'il respecte les $3$ contraintes suivantes :\\
\begin{itemize}
	\item avoir un cycle de longueur N (avec main\_cycle\_length(N))
	\item tout les états globaux du chemin visités après l'étape N (avec main\_cycle\_length(N)) doivent être des éléments du cycle
	\item toutes les transitions globales jouables depuis chacun des éléments du cycle doivent arriver dans un autre élément de ce cycle ( = domaine piège)\\
\end{itemize}
Les deux premières conditions se vérifient assez aisèment.\\ \\
Pour la première, on crée un prédicat \textcolor{blue}{\emph{different\_states\_on(Step1, Step2, Automaton)}} nous permettant de déduire si deux états globaux atteints à $Step1$ et $Step2$ sont différents ou pas. On en déduit alors 
un prédicat \textcolor{blue}{\emph{same\_state(Step1, Step2)}}, et il ne nous reste qu'à ajouter la contrainte \textcolor{blue}{\emph{:- not same\_state(0, N), main\_cycle\_length(N).}}\\ \\
Quant à la seconde, il nous suffit de créer un prédicat \textcolor{blue}{\emph{valid\_state\_after\_main\_cycle(Step2)}} vrai lorsqu'il existe une étape $Step1$ dans le cycle principal et une étape $Step2$ en dehors du cycle 
principal telles que l'on ait l'atome \textcolor{blue}{\emph{same\_state(Step1, Step2)}} qui soit vrai. Ce prédicat devant être toujours vrai pour chaque $Step2$, on rajoute finalement la contrainte suivante : 
\textcolor{blue}{\emph{:- not valid\_state\_after\_main\_cycle(Step1), after\_cycle\_step(Step1).}}\\ \\
La troisième contrainte contenait la raison du bug du code. Comme la modélisation actuelle des choses ne mémorise pas quels sont les coups jouables pour la sémantique choisie (initialement l'idée était d'avoir un code qui fonctionne 
pour toutes les sémantiques en scindant le fichier ASP en deux : recherche des attracteurs, et sémantique, ce qui permettait d'avoir un seul solveur d'attracteur, universel pour toutes les sémantiques), cela n'était pas 
possible.\\ \\
Deux options étaient alors envisageables pour résoudre ce problème : faire un script ASP dans laquelle je rajoute la dernière contrainte en introduisant une notion d'état global ; ou bien utiliser Python pour résoudre ce problème 
lors du solving de clingo. Comme dit précédemment, je ne parlerais que de la seconde option.

\subsection{Résolution de la troisième contrainte en Python}
Je ne vais pas rentrer en détail dans la manière dont on peut réussir à récupérer des atomes lors du grounding et du solving d'ASP en Python, mais sachez seulement que cela est faisable. Nous avons donc en Python une boucle for 
qui va, à chaque instance, avoir un ensemble d'atomes tous vrais tel que l'interprétation qu'il forme satisfasse toutes les règles de notre programme ASP.\\ \\
Lors de la première itération de cette boucle, il est nécessaire de mémoriser toutes les transitions, les conditions, ainsi que les cibles de ces transitions.\\ \\
\emph{
	On commence par créer des ensembles vides, ainsi qu'une variable booléenne pour savoir si nous avons déjà mémorisé ce que l'on souhaite.\\ \\
	\textcolor{white}{2c}\#Ensemble Python pour les conditions des transitions ([transition][automata] = level).\\
	1. \textcolor{blue}{condition\_transitions = \{\}}\\ \\
	\textcolor{white}{2c}\#Ensemble Python pour l'automate cible des transitions ([transition] = automaton\_name).\\
	2. \textcolor{blue}{target\_transitions\_automaton\_name = \{\}}\\ \\
	\textcolor{white}{2c}\#Ensemble Python pour le niveau cible des transitions ([transition] = level).\\
	3. \textcolor{blue}{target\_transitions\_automaton\_level = \{\}}\\ \\
	\textcolor{white}{2c}\#Une variable booléenne pour dire si les 3 ensembles précédents sont déjà créés ou pas.\\
	4. \textcolor{blue}{transitions\_already\_done = False}\\ \\
	\textcolor{blue}{Boucle for magique}\\
	Ensuite, dans notre boucle for magique, on introduit une variable associé à l'attracteur courant, qu'on remplit, ainsi que les 3 autres variables.\\ \\
	5. \textcolor{blue}{cur\_dict = \{\}}\\
	6. \textcolor{blue}{for x in cur\_model.symbols(shown = True):}\\
		\textcolor{white}{2c}\qquad\qquad\#On considère les atomes 'active(level(AUTOMATA, LEVEL), STEP)'\\
		7.\qquad\qquad\textcolor{blue}{if x.name == 'active' and x.arguments[0].name == 'level':}\\
			8.\qquad\qquad\qquad\textcolor{blue}{step\_number = x.arguments[1].number}\\
			9.\qquad\qquad\qquad\textcolor{blue}{automata\_name = x.arguments[0].arguments[0].string}\\
			10.\qquad\qquad\qquad\textcolor{blue}{active\_level = x.arguments[0].arguments[1].number}\\
			\textcolor{white}{3ch}\qquad\qquad\qquad\#Si c'est un nouveau numéro d'étape\\
			11.\qquad\qquad\qquad\textcolor{blue}{if step\_number not in cur\_dict:}\\
				\textcolor{white}{3ch}\qquad\qquad\qquad\qquad\#On le rajoute dans le dictionnaire\\
				12.\qquad\qquad\qquad\qquad\textcolor{blue}{cur\_dict[step\_number] = \{\}}\\
			\textcolor{white}{3ch}\qquad\qquad\qquad\#A priori il n'y a pas plusieurs niveaux pour un automate à une étape (?)\\
			13.\qquad\qquad\qquad\textcolor{blue}{assert automata\_name not in cur\_dict[step\_number]}\\
			14.\qquad\qquad\qquad\textcolor{blue}{cur\_dict[step\_number][automata\_name] = active\_level}\\ \\
		\textcolor{white}{3ch}\qquad\qquad\#Création des 3 ensembles pour les transitions si ce n'est pas déjà fait\\
		15.\qquad\qquad\textcolor{blue}{elif not transitions\_already\_done :}\\
			\textcolor{white}{3ch}\qquad\qquad\qquad\#On considère les atomes 'condition(TRANSITION, AUTOMATA, LEVEL)'\\
			16.\qquad\qquad\qquad\textcolor{blue}{if x.name == 'condition' :}\\
				17.\qquad\qquad\qquad\qquad\textcolor{blue}{transition = x.arguments[0].name}\\
				18.\qquad\qquad\qquad\qquad\textcolor{blue}{automata\_name = x.arguments[1].string}\\
				19.\qquad\qquad\qquad\qquad\textcolor{blue}{level = x.arguments[2].number}\\
				\textcolor{white}{3ch}\qquad\qquad\qquad\qquad\#Si c'est une nouvelle transition\\
				20.\qquad\qquad\qquad\qquad\textcolor{blue}{if transition not in condition\_transitions:}\\
					\textcolor{white}{3ch}\qquad\qquad\qquad\qquad\qquad\#On la rajoute dans le dictionnaire\\
					21.\qquad\qquad\qquad\qquad\qquad\textcolor{blue}{condition\_transitions[transition] = \{\}}\\
				22.\qquad\qquad\qquad\qquad\textcolor{blue}{assert automata\_name not in condition\_transitions[transition]}\\
				23.\qquad\qquad\qquad\qquad\textcolor{blue}{condition\_transitions[transition][automata\_name] = level}\\
			\textcolor{white}{3ch}\qquad\qquad\qquad\#On considère les atomes 'target(TRANSITION, AUTOMATA, LEVEL)'\\
			24.\qquad\qquad\qquad\textcolor{blue}{elif x.name == 'target' :}\\
				25.\qquad\qquad\qquad\qquad\textcolor{blue}{transition = x.arguments[0].name}\\
				26.\qquad\qquad\qquad\qquad\textcolor{blue}{automata\_name = x.arguments[1].string}\\
				27.\qquad\qquad\qquad\qquad\textcolor{blue}{level = x.arguments[2].number}\\
				\textcolor{white}{3ch}\qquad\qquad\qquad\qquad\#A priori il n'y a qu'un atome target par transition\\
				28.\qquad\qquad\qquad\qquad\textcolor{blue}{assert transition not in (target\_transitions\_automaton\_name}\\
				\textcolor{white}{3ch}\qquad\qquad\qquad\qquad\qquad$\hookrightarrow$ \textcolor{blue}{or target\_transitions\_automaton\_level)}\\
				\textcolor{white}{3ch}\qquad\qquad\qquad\qquad\#Donc on vient rajouter ces informations dans nos ensembles\\
				29.\qquad\qquad\qquad\qquad\textcolor{blue}{target\_transitions\_automaton\_name[transition] = automata\_name}\\
				30.\qquad\qquad\qquad\qquad\textcolor{blue}{target\_transitions\_automaton\_level[transition] = level}\\
	\textcolor{white}{3ch}\#Cette dernière ligne nous certifie qu'on ne crée qu'une fois les 3 ensembles\\
	31. \textcolor{blue}{transitions\_already\_done = True}\\ \\
	On introduit deux variables.\\ \\
	\textcolor{white}{3ch}\#La liste des noms d'automates triée par ordre alphabétique.\\
	32. \textcolor{blue}{sorted\_automata\_names == []}\\
	33. \textcolor{blue}{if sorted\_automata\_names == []:}\\
		34.\qquad\textcolor{blue}{sorted\_automata\_names = sorted(cur\_dict[0])}\\ \\
	\textcolor{white}{3ch}\#Ensemble (non ordonné) d'états dans l'attracteur courant.\\
	35. \textcolor{blue}{cur\_set = set()}\\
	\textcolor{white}{3ch}\#Pour chaque étape\\
	36. \textcolor{blue}{for step\_number in cur\_dict:}\\
		\textcolor{white}{3ch}\qquad\#On ajoute l'état correspondant à cur\_set\\
		37.\qquad\textcolor{blue}{cur\_set.add(tuple(cur\_dict[step\_number][automata\_name]}\\
		\textcolor{white}{3ch}\qquad\qquad\qquad\qquad$\hookrightarrow$ \textcolor{blue}{for automata\_name in sorted\_automata\_names))}\\ \\
	On commence par créer et compléter l'ensemble des transitions locales jouables depuis chacun des états globaux de l'attracteur courant.\\ \\
	\textcolor{white}{3ch}\#playable est l'ensemble de toutes les transitions locales jouables depuis chaque état global de l'attracteur courant et chaque automate de celui-ci. Il est de la forme playable[global\_state]
	[automata\_name][transition] = level où 'level' est le niveau de l'automate après la transition.\\
	38. \textcolor{blue}{playable = \{\}}\\
	39. \textcolor{blue}{number\_automaton = len(sorted\_automata\_names)}\\
	\textcolor{white}{3ch}\#Pour chaque automate de l'attracteur courant\\
	40. \textcolor{blue}{for global\_state in cur\_set:}\\
		41.\qquad\textcolor{blue}{playable[global\_state] = \{\}}\\
		\textcolor{white}{3ch}\qquad\#Pour chaque transition\\
		42.\qquad\textcolor{blue}{for transition in condition\_transitions:}\\
			\textcolor{white}{3ch}\qquad\qquad\#On teste si elle est jouable pour l'état global courant\\
			43.\qquad\qquad\textcolor{blue}{can\_be\_played = True}\\
			\textcolor{white}{3ch}\qquad\qquad\#En regardant pour chaque condition de la transition\\
			44.\qquad\qquad\textcolor{blue}{for automata\_name in condition\_transitions[transition]:}\\
				45.\qquad\qquad\qquad\textcolor{blue}{if automata\_name not in playable[global\_state]:}\\
					46.\qquad\qquad\qquad\qquad\textcolor{blue}{playable[global\_state][automata\_name] = \{\}}\\
				\textcolor{white}{3ch}\qquad\qquad\qquad\#Si elle est vérifiée ou pas\\
				47.\qquad\qquad\qquad\textcolor{blue}{if global\_state[sorted\_automata\_names.index(automata\_name)] != }\\
				\textcolor{white}{3ch}\qquad\qquad\qquad\qquad\qquad$\hookrightarrow$ \textcolor{blue}{condition\_transitions[transition][automata\_name]:}\\
					48.\qquad\qquad\qquad\qquad\textcolor{blue}{can\_be\_played = False}\\
			\textcolor{white}{3ch}\qquad\qquad\#Si elle est bien jouable\\
			49.\qquad\qquad\textcolor{blue}{if can\_be\_played:}\\
				50.\qquad\qquad\qquad\textcolor{blue}{automata\_name = target\_transitions\_automaton\_name[transition]}\\
				51.\qquad\qquad\qquad\textcolor{blue}{level = target\_transitions\_automaton\_level[transition]}\\
				\textcolor{white}{3ch}\qquad\qquad\qquad\#On l'ajoute au dictionnaire\\
				52.\qquad\qquad\qquad\textcolor{blue}{playable[global\_state][automata\_name][transition] = level}\\ \\
	\textcolor{white}{3ch}\#list\_of\_list est une liste de listes de listes d'entiers. Pour faire simple, chacune de ses sous-listes représente un état global de l'attracteur courant. Chacune des sous-listes de ces états 
	globaux représente un automate, et chacune des sous-listes de cet automate correspond à l'ensemble des niveaux dans lesquels il peut se retrouver après une transition locale jouable depuis l'état global. 
	Si aucune transition locale n'est jouable, la sous-liste de l'automate en question sera vide.\\
	53. \textcolor{blue}{list\_of\_list = []}\\
	\textcolor{white}{3ch}\#Pour chaque état global de l'attracteur courant\\
	54. \textcolor{blue}{for global\_state in playable:}\\
		\textcolor{white}{3ch}\qquad\#On crée une liste pour l'état global courant\\
		55.\qquad\textcolor{blue}{list\_for\_current\_state = []}\\
		\textcolor{white}{3ch}\qquad\#Pour chaque automate\\
		56.\qquad\textcolor{blue}{for automaton\_name in sorted\_automata\_names:}\\
			\textcolor{white}{3ch}\qquad\qquad\#On crée une liste pour l'automate courant\\
			57.\qquad\qquad\textcolor{blue}{list\_for\_automaton = []}\\
			\textcolor{white}{3ch}\qquad\qquad\#Si aucune transition locale n'est jouable pour l'automate, on le laisse à son niveau\\
			58.\qquad\qquad\textcolor{blue}{if playable[global\_state][automaton\_name] == \{\}:}\\
				59.\qquad\qquad\qquad\textcolor{blue}{list\_for\_automaton.append(global\_state[sorted\_automata\_names.index(}\\
				\textcolor{white}{3ch}\qquad\qquad\qquad\qquad\qquad$\hookrightarrow$ \textcolor{blue}{automaton\_name)])}\\
			\textcolor{white}{3ch}\qquad\qquad\#Sinon\\
			60.\qquad\qquad\textcolor{blue}{else:}\\
				\textcolor{white}{3ch}\qquad\qquad\qquad\#Pour chaque transition locale jouable\\
				61.\qquad\qquad\qquad\textcolor{blue}{for transition in playable[global\_state][automaton\_name]:}\\
					\textcolor{white}{3ch}\qquad\qquad\qquad\qquad\#On détermine le niveau après transition\\
					62.\qquad\qquad\qquad\qquad\textcolor{blue}{level = playable[global\_state][automaton\_name][transition]}\\
					\textcolor{white}{3ch}\qquad\qquad\qquad\qquad\#Et on l'ajoute à la liste des niveaux atteignables pour l'automate\\
					63.\qquad\qquad\qquad\qquad\textcolor{blue}{list\_for\_automaton.append(level)}\\
			64.\qquad\qquad\textcolor{blue}{list\_for\_current\_state.append(list\_for\_automaton)}\\
		65.\qquad\textcolor{blue}{list\_of\_list.append(list\_for\_current\_state)}\\ \\
	\textcolor{white}{3ch}\# list\_of\_product est la liste des produits cartésiens de chaque coup possible pour un état global. Il s'agit donc d'une liste d'états globaux atteignables depuis nos états présents dans le cycle 
	principal.\\
	66. \textcolor{blue}{list\_of\_product = []}\\
	67. \textcolor{blue}{for l in list\_of\_list:}\\
		\textcolor{white}{3ch}\qquad\# product est une fonction réalisant un produit cartésien de listes\\
		68.\qquad\textcolor{blue}{list\_of\_product += list(product(tuple(l)))}\\ \\
	\textcolor{white}{3ch}\# Enfin, on s'assure que chaque élément de list\_of\_product est bien un élément du cycle principal. De cette façon, notre attracteur vérifiera bien la troisième condition, et sera valide.\\
	69. \textcolor{blue}{neighbours\_are\_main\_states = True}\\
	70. \textcolor{blue}{for global\_state in list\_of\_product:}\\
		71.\qquad\textcolor{blue}{if global\_state not in cur\_set:}\\
		72.\qquad\qquad\textcolor{blue}{neighbours\_are\_main\_states = False}\\ \\
	\textcolor{blue}{Manipulation pour filtrer proprement les attracteurs et pas leur trace}\\
	$\rightarrow$ On ne renvoie un attracteur que s'il n'a pas déjà été renvoyé (puisque jusqu'ici, si on parcourt notre cycle depuis un autre 
	point de départ, on renvoie un second ensemble solution alors qu'en réalité il s'agit du même attracteur).\\ \\
	\textcolor{blue}{Fin boucle for magique}\\
}
\subsection{Légère modification pour sémantique généralisée}
En reprenant le code présenté ci-dessus, j'ai également fait une version pour la sémantique généralisée (la version de laquelle je suis parti fonctionnant très bien pour la sémantique asynchrone, je n'ai rien à dire 
dessus). En effet, la différence avec la sémantique synchrone est que l'on peut faire changer nos automates ou pas, mais qu'au moins un de tous les automates doit changer de niveau lorsque l'on recherche quelles sont les 
transitions globales jouables.
Concrètement, il faut modifier la sémantique :\\ \\
\emph{
	\verb![...]!\\
	\% On sélectionne \underline{0 ou 1} transition à jouer pour chaque automate\\
	18. \textcolor{blue}{\textcolor{red}{0} \{played(Transition, Step) :}\\
	19.\qquad\qquad\textcolor{blue}{not unplayable(Transition, Step),}\\
	20.\qquad\qquad\textcolor{blue}{local\_transition(Transition, Automaton)}\\
	21. \textcolor{blue}{\} 1 :- has\_playable(Automaton, Step).}\\
	\verb![...]!\\
}
On doit ensuite modifier dans le code python le fait que list\_fo\_automaton soit initialement vide : pour chaque automate, on peut soit rester dans cet automate, soit faire une des transitions trouvés. Pour cela, on modifie la 
ligne 57 et les suivantes comme ceci :\\ \\
\emph{
	\verb![...]!\\
		57.\qquad\qquad\textcolor{blue}{list\_for\_automaton = [global\_state[sorted\_automata\_names.index(automaton\_name)]]}\\
		\textcolor{white}{3ch}\qquad\qquad\#Pour chaque transition locale jouable\\
		58.\qquad\qquad\textcolor{blue}{for transition in playable[global\_state][automaton\_name]:}\\
			\textcolor{white}{3ch}\qquad\qquad\qquad\#On détermine le niveau après transition\\
			59.\qquad\qquad\qquad\textcolor{blue}{level = playable[global\_state][automaton\_name][transition]}\\
			\textcolor{white}{3ch}\qquad\qquad\qquad\#Et on l'ajoute à la liste des niveaux atteignables pour l'automate\\
			60.\qquad\qquad\qquad\textcolor{blue}{list\_for\_automaton.append(level)}\\
		61.\qquad\qquad\textcolor{blue}{list\_for\_current\_state.append(list\_for\_automaton)}\\
	62.\qquad\textcolor{blue}{list\_of\_list.append(list\_for\_current\_state)}\\ \\
	\verb![...]!\\
}

\subsection{Quelques mots sur la seconde manière de procéder}
L'autre solution que je voyais pour résoudre le problème qu'on rencontrait mon maître de stage et ses collègues était de déclarer des prédicats \emph{\textcolor{blue}{global\_state(Gs)}} représentant les états globaux du réseau. 
Cela permet de déclarer dans des fichiers pour les sémantiques quels sont les transitions locales jouables en utilisant un prédicat \emph{\textcolor{blue}{playable(Gs1, Gs2)}} signifiant que l'on peut aller depuis 
$Gs1$ en $Gs2$.\\ \\
Le principal défaut de cette manière de procéder est que cela crée de nombreux atomes et demande à ASP de les garder en mémoire pendant tout son solving. De plus, déterminer si pour toute paire d'états globaux il existe une 
transition se fait en $O(k^2)$, avec $k=\displaystyle{\prod_{a\in\Sigma}C_a}$, alors que si l'on calcule les transitions jouables à chaque étape, on ne surcharge pas la mémoire du solveur. C'est à priori ce qui rend mon programme 
obsolète en terme de complexité.

\newpage
\section{Conclusion et pistes pour la suite}
Durant mon stage j'ai élaboré deux versions pour résoudre le problème rencontré avec l'ajout de la troisième contrainte. J'ai présenté dans ce rapport la solution qui fait appel à un script Python, ainsi que la version modifiée 
pour traiter la sémantique généralisée. J'ai très brièvement parlé de la solution nécessitant la création d'états globaux en ASP.\\ \\
Mes performances sur la batterie de test qu'à utiliser Maxime pour la version de laquelle je suis parti se sont avérés tout aussi bonne que celles de la sémantique asynchrone. Les résultats de ces tests sont dans les annexes. Les 
performances de ma seconde version y sont également. On voit notamment à quel point elle n'est pas efficace en temps.\\ \\
Concernant cette seconde version, je pense que l'on peut grandement améliorer son efficacité en combinant mon code avec de l'incrémental. L'idée serait de ne considérer qu'un certains nombres d'états globaux : au début on les 
considère tous, puis, lorsque l'on trouve un attracteur, on regroundre le programme en enlevant tout les états globaux de l'attracteur (en les mettant tous à faux).\\ \\
Une autre idée que j'avais en tête était, lorsque l'on trouvait un cycle qui n'était pas un attracteur, de remplacer tout les états de ce cycle par un seul représentant, dont les transitions globales entrantes et sortantes 
seront celles de chacun des états globaux du cycle. On travaillerait ensuite avec des représentants et des états globaux comme s'il s'agissait du même objet (si on a un représentant dans un autre cycle, on l'agrandira en rajoutant 
les autres éléments du cycle). Je pense que combiner cette idée avec de l'incrémental pourrait également être intéressant : à chaque cycle trouvé on effectue de nouveau un grounding en mettant à jour nos représentants.\\ \\
Je ne suis pas sûr de ces pistes, mais c'est ce sur quoi j'essaierais personnellement de me pencher pour poursuivre le travail.\\ \\ \\
Enfin, je souhaite remercier l'ENS de Lyon qui m'a proposé ce stage, Maxime F. pour son encadrement, les personnes au sein de l'équipe BioComputing, mes quelques collègues stagiaires de bureau (même si le stage a été en 
semi-distanciel) ainsi que mes quelques relecteurs anonymes.

\newpage
\bibliography{biblio}

\end{document}





























